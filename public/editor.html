<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Originals World - Editor de Mapa</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }

/* Sidebar */
#sidebar {
  width: 260px;
  background: #16213e;
  border-right: 2px solid #0f3460;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
#sidebar h2 {
  padding: 12px;
  text-align: center;
  background: #0f3460;
  font-size: 15px;
  letter-spacing: 1px;
}
#tools {
  padding: 8px;
  border-bottom: 1px solid #0f3460;
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}
#tools button {
  padding: 6px 10px;
  background: #1a1a40;
  color: #ccc;
  border: 1px solid #333;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}
#tools button:hover { background: #2a2a60; }
#tools button.active { background: #e94560; color: #fff; border-color: #e94560; }
#brush-size {
  padding: 6px 8px;
  display: flex;
  align-items: center;
  gap: 6px;
  border-bottom: 1px solid #0f3460;
  font-size: 12px;
}
#brush-size input { width: 50px; }
#search-box {
  padding: 6px 8px;
  border-bottom: 1px solid #0f3460;
}
#search-box input {
  width: 100%;
  padding: 5px 8px;
  background: #1a1a40;
  color: #eee;
  border: 1px solid #333;
  border-radius: 4px;
  font-size: 12px;
}
#palette {
  flex: 1;
  overflow-y: auto;
  padding: 4px;
}
.tile-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  width: calc(100% - 4px);
  margin: 2px;
  padding: 4px 6px;
  background: #1a1a40;
  border: 2px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  color: #ccc;
  font-size: 11px;
  text-align: left;
}
.tile-btn:hover { background: #2a2a60; }
.tile-btn.selected { border-color: #e94560; background: #2a1a30; }
.tile-preview {
  width: 24px;
  height: 24px;
  border: 1px solid #444;
  border-radius: 2px;
  flex-shrink: 0;
}
#status-bar {
  padding: 8px;
  background: #0f3460;
  font-size: 11px;
  display: flex;
  justify-content: space-between;
}

/* Canvas area */
#canvas-area {
  flex: 1;
  position: relative;
  overflow: hidden;
}
#mapCanvas {
  position: absolute;
  top: 0;
  left: 0;
  image-rendering: pixelated;
}
#coords {
  position: absolute;
  top: 8px;
  left: 8px;
  background: rgba(0,0,0,0.7);
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 12px;
  pointer-events: none;
}
#help-overlay {
  position: absolute;
  bottom: 8px;
  left: 8px;
  background: rgba(0,0,0,0.7);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 11px;
  pointer-events: none;
  line-height: 1.6;
}
#quadrant-select {
  position: absolute;
  top: 8px;
  right: 8px;
  background: rgba(0,0,0,0.7);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  display: flex;
  gap: 6px;
  align-items: center;
}
#quadrant-select select {
  background: #1a1a40;
  color: #eee;
  border: 1px solid #444;
  padding: 3px 6px;
  border-radius: 3px;
}
#save-btn {
  position: absolute;
  top: 8px;
  right: 200px;
  padding: 6px 16px;
  background: #27ae60;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  font-weight: bold;
}
#save-btn:hover { background: #2ecc71; }
#undo-btn {
  position: absolute;
  top: 8px;
  right: 300px;
  padding: 6px 12px;
  background: #e67e22;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
}
#undo-btn:hover { background: #f39c12; }
#grid-toggle {
  position: absolute;
  top: 44px;
  right: 8px;
  padding: 4px 10px;
  background: rgba(0,0,0,0.7);
  color: #aaa;
  border: 1px solid #555;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
}
#toast {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(39,174,96,0.9);
  color: #fff;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: bold;
  display: none;
  pointer-events: none;
  z-index: 100;
}
</style>
</head>
<body>

<div id="sidebar">
  <h2>üó∫Ô∏è EDITOR DE MAPA</h2>
  <div id="tools">
    <button id="tool-paint" class="active" onclick="setTool('paint')">üñåÔ∏è Pintar</button>
    <button id="tool-erase" onclick="setTool('erase')">üßπ Apagar</button>
    <button id="tool-fill" onclick="setTool('fill')">ü™£ Preencher</button>
    <button id="tool-pick" onclick="setTool('pick')">üíâ Pegar</button>
    <button id="tool-rect" onclick="setTool('rect')">‚¨ú Ret√¢ngulo</button>
    <button id="tool-line" onclick="setTool('line')">üìè Linha</button>
    <button id="tool-image" onclick="setTool('image')">üñºÔ∏è Imagem</button>
    <button id="tool-selectobj" onclick="setTool('selectobj')">‚úã Selec Obj</button>
    <button id="tool-npc" onclick="setTool('npc')" style="background:#1a3a40;">üë§ NPCs</button>
    <button id="tool-collision" onclick="setTool('collision')" style="background:#401a1a;">üß± Colis√£o</button>
  </div>
  <div id="brush-size">
    <label>Pincel:</label>
    <input type="range" id="brushRange" min="1" max="10" value="1" oninput="brushSize=+this.value; document.getElementById('brushVal').textContent=this.value">
    <span id="brushVal">1</span>
  </div>
  <div id="solid-toggle" style="padding:4px 8px; border-bottom:1px solid #0f3460; display:flex; align-items:center; gap:6px;">
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showSolids" checked onchange="showBlockedOverlay=this.checked; renderMap()">
      <span>Mostrar s√≥lidos</span>
    </label>
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showCollision" checked onchange="showCollisionOverlay=this.checked; renderMap()">
      <span>Mostrar colis√£o</span>
    </label>
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showNpcs" checked onchange="showNpcOverlay=this.checked; renderMap()">
      <span>Mostrar NPCs</span>
    </label>
  </div>
  <div id="collision-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none; background:#2a1515;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üß± Ferramenta de Colis√£o</div>
    <div style="font-size:11px; color:#ccc; line-height:1.5;">
      <b>Bot√£o Direito</b> = marcar s√≥lido<br>
      <b>Bot√£o Esquerdo</b> = remover s√≥lido<br>
      Use o pincel para controlar o tamanho.
    </div>
    <div style="font-size:10px; color:#888; margin-top:4px;">C√©lulas s√≥lidas: <span id="solidCount">0</span></div>
  </div>
  <div id="npc-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none; background:#152a2a;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üë§ NPCs do Quadrante</div>
    <div id="npc-list" style="font-size:11px;"></div>
    <div style="font-size:10px; color:#888; margin-top:4px;">Arraste os NPCs no mapa para reposicionar.</div>
  </div>
  <div id="image-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none;">
    <label style="font-size:12px;">Imagem:</label>
    <input type="file" id="imageFile" accept="image/*" style="width:100%; margin:4px 0; font-size:11px; color:#ccc;" onchange="onImageSelected(this)">
    <div style="display:flex; gap:4px; margin:4px 0;">
      <label style="font-size:11px;">Larg (tiles):</label>
      <input type="number" id="imgW" value="3" min="1" max="50" style="width:45px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;">
      <label style="font-size:11px;">Alt:</label>
      <input type="number" id="imgH" value="3" min="1" max="50" style="width:45px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;">
    </div>
    <div id="imgPreview" style="max-width:100%; max-height:80px; margin:4px 0; text-align:center;"></div>
    <div style="font-size:10px; color:#888;">Clique no mapa para posicionar</div>
  </div>
  <div id="obj-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üì¶ Objeto Selecionado</div>
    <div id="objPreview" style="max-width:100%; max-height:60px; margin:4px 0; text-align:center;"></div>
    <div style="display:flex; gap:4px; margin:4px 0; align-items:center;">
      <label style="font-size:11px;">X:</label>
      <input type="number" id="objX" min="0" max="99" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateSelectedObjProps()">
      <label style="font-size:11px;">Y:</label>
      <input type="number" id="objY" min="0" max="99" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateSelectedObjProps()">
    </div>
    <div style="display:flex; gap:4px; margin:4px 0; align-items:center;">
      <label style="font-size:11px;">Larg:</label>
      <input type="number" id="objW" min="1" max="50" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateSelectedObjProps()">
      <label style="font-size:11px;">Alt:</label>
      <input type="number" id="objH" min="1" max="50" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateSelectedObjProps()">
    </div>
    <div style="display:flex; gap:4px; margin-top:6px;">
      <button onclick="deleteSelectedObj()" style="flex:1; padding:4px 8px; background:#aa2020; color:#fff; border:none; border-radius:3px; cursor:pointer; font-size:11px;">üóëÔ∏è Deletar</button>
      <button onclick="deselectObj()" style="flex:1; padding:4px 8px; background:#555; color:#fff; border:none; border-radius:3px; cursor:pointer; font-size:11px;">‚úñ Deselecionar</button>
    </div>
    <div style="font-size:10px; color:#888; margin-top:4px;">Arraste para mover no mapa</div>
  </div>
  <div id="search-box">
    <input type="text" id="tileSearch" placeholder="Buscar tile..." oninput="filterTiles(this.value)">
  </div>
  <div id="palette"></div>
  <div id="status-bar">
    <span id="selectedInfo">GRASS (0)</span>
    <span id="mapSize">100x100</span>
  </div>
</div>

<div id="canvas-area">
  <canvas id="mapCanvas"></canvas>
  <div id="coords">X: 0, Y: 0</div>
  <div id="help-overlay">
    Scroll = Zoom | Arrastar Direito = Mover<br>
    Click Esq = Pintar | Ctrl+Z = Desfazer<br>
    E = Pegar tile | G = Grid | F = Preencher<br>
    I = Imagem | S = Selec Objeto<br>
    N = NPCs | C = Colis√£o (Dir=S√≥lido, Esq=Normal)
  </div>
  <div id="quadrant-select">
    <label>Mapa:</label>
    <select id="quadSelect" onchange="loadQuadrant(this.value)">
      <option value="E5">E5 - Cidade</option>
      <option value="E4">E4 - Plan√≠cie</option>
      <option value="F5">F5 - Vila de Testes</option>
    </select>
  </div>
  <button id="save-btn" onclick="saveMap()">üíæ Salvar</button>
  <button id="undo-btn" onclick="undo()">‚Ü© Desfazer</button>
  <button id="grid-toggle" onclick="toggleGrid()">Grid: ON</button>
  <div id="toast"></div>
</div>

<script>
// ============================
// TILE DEFINITIONS
// ============================
const T = {
  GRASS:0, DIRT:1, STONE_PATH:2, STONE_WALL:3, WATER:4, TREE:5, WOOD_FLOOR:6,
  CHURCH_FLOOR:7, WOOD_WALL:8, SAND:9, FLOWERS:10, BUSH:11, ROCK:12,
  RED_CARPET:13, ALTAR:14, ANVIL:15, FURNACE:16, BOOKSHELF:17, TABLE:18,
  CHAIR:19, WELL:20, FENCE:21, ROOF_STONE:22, ROOF_WOOD:23, WINDOW_STONE:24,
  WINDOW_WOOD:25, CROSS:26, TALL_GRASS:27, MUSHROOM:28, BARREL:29, CRATE:30,
  TORCH_WALL:31, BED:32, RUG:33, CHURCH_PEW:34, DARK_GRASS:35,
  GRAVESTONE:36, DEAD_TREE:37, BONE:38, MUD:39, HAY:40, CHURCH_WALL:41,
  ROOF_RED:42, ROOF_BLUE:43, ROOF_YELLOW:44, BENCH:45
};

// Color map for rendering tiles on the editor
const TILE_COLORS = {
  [T.GRASS]: '#3a7a2c',
  [T.DARK_GRASS]: '#2a5c18',
  [T.TALL_GRASS]: '#4a9a3a',
  [T.FLOWERS]: '#5a8c4f',
  [T.MUSHROOM]: '#3a7a2c',
  [T.BUSH]: '#1e5c10',
  [T.ROCK]: '#888',
  [T.DIRT]: '#8b6b3d',
  [T.STONE_PATH]: '#999',
  [T.STONE_WALL]: '#666',
  [T.WATER]: '#2060c0',
  [T.TREE]: '#1d4b0e',
  [T.WOOD_FLOOR]: '#a07850',
  [T.CHURCH_FLOOR]: '#b0a880',
  [T.RED_CARPET]: '#aa2020',
  [T.ALTAR]: '#ddd',
  [T.CROSS]: '#d4a750',
  [T.CHURCH_PEW]: '#6a4020',
  [T.BOOKSHELF]: '#5a3a1a',
  [T.WOOD_WALL]: '#6a4420',
  [T.WINDOW_STONE]: '#66aadd',
  [T.WINDOW_WOOD]: '#88bbdd',
  [T.TABLE]: '#8a6040',
  [T.CHAIR]: '#7a5030',
  [T.WELL]: '#556',
  [T.FENCE]: '#8a6530',
  [T.ROOF_STONE]: '#606060',
  [T.ROOF_WOOD]: '#7a4828',
  [T.SAND]: '#d4c080',
  [T.ANVIL]: '#555',
  [T.FURNACE]: '#884422',
  [T.BARREL]: '#7a5020',
  [T.CRATE]: '#8a6530',
  [T.TORCH_WALL]: '#ff8800',
  [T.BED]: '#884444',
  [T.RUG]: '#993333',
  [T.MUD]: '#5a4020',
  [T.HAY]: '#c8a830',
  [T.GRAVESTONE]: '#888',
  [T.DEAD_TREE]: '#3a2a10',
  [T.BONE]: '#ddd8c0',
  [T.CHURCH_WALL]: '#777788',
  [T.ROOF_RED]: '#aa2020',
  [T.ROOF_BLUE]: '#2050aa',
  [T.ROOF_YELLOW]: '#c8a020',
  [T.BENCH]: '#8a6a40',
};

// Tile icons/symbols for the editor
const TILE_ICONS = {
  [T.GRASS]: 'üü©', [T.DARK_GRASS]: 'üåø', [T.TALL_GRASS]: 'üåæ',
  [T.FLOWERS]: 'üå∏', [T.MUSHROOM]: 'üçÑ', [T.BUSH]: 'üå≥',
  [T.ROCK]: 'ü™®', [T.DIRT]: 'üü´', [T.STONE_PATH]: '‚¨ú',
  [T.STONE_WALL]: 'üß±', [T.WATER]: 'üü¶', [T.TREE]: 'üå≤',
  [T.WOOD_FLOOR]: 'üüß', [T.CHURCH_FLOOR]: '‚¨ú', [T.RED_CARPET]: 'üü•',
  [T.ALTAR]: '‚õ™', [T.CROSS]: '‚úùÔ∏è', [T.CHURCH_PEW]: 'ü™ë',
  [T.BOOKSHELF]: 'üìö', [T.WOOD_WALL]: 'üü´', [T.WINDOW_STONE]: 'ü™ü',
  [T.WINDOW_WOOD]: 'ü™ü', [T.TABLE]: 'ü™µ', [T.CHAIR]: 'ü™ë',
  [T.WELL]: '‚õ≤', [T.FENCE]: 'üèóÔ∏è', [T.ROOF_STONE]: 'üè†',
  [T.ROOF_WOOD]: 'üè°', [T.SAND]: 'üü®', [T.ANVIL]: 'üî®',
  [T.FURNACE]: 'üî•', [T.BARREL]: 'üõ¢Ô∏è', [T.CRATE]: 'üì¶',
  [T.TORCH_WALL]: 'üî•', [T.BED]: 'üõèÔ∏è', [T.RUG]: 'üü´',
  [T.MUD]: 'üí©', [T.HAY]: 'üåæ', [T.GRAVESTONE]: 'ü™¶',
  [T.DEAD_TREE]: 'üåµ', [T.BONE]: 'ü¶¥', [T.CHURCH_WALL]: 'üèõÔ∏è',
  [T.ROOF_RED]: 'üî¥', [T.ROOF_BLUE]: 'üîµ', [T.ROOF_YELLOW]: 'üü°', [T.BENCH]: 'ü™ë'
};

const TILE_NAMES = {};
for (const [name, id] of Object.entries(T)) {
  TILE_NAMES[id] = name;
}

// ============================
// STATE
// ============================
let mapData = null;
let mapW = 100, mapH = 100;
let currentQuadrant = 'E5';
let selectedTile = T.GRASS;
let currentTool = 'paint';
let brushSize = 1;
let showGrid = true;
let zoom = 1;
let offsetX = 0, offsetY = 0;
let isPanning = false;
let panStartX = 0, panStartY = 0;
let isPainting = false;
let undoStack = [];
const MAX_UNDO = 50;
let rectStart = null; // for rect tool
let lineStart = null; // for line tool
let blockedTiles = new Set();
let showBlockedOverlay = true;
let showCollisionOverlay = true;
let showNpcOverlay = true;

// Per-cell solid grid
let solidCellSet = new Set(); // "x,y" strings
let isCollisionPainting = false;
let collisionPaintMode = null; // 'add' or 'remove'

// NPC data
let editorNpcs = []; // {id, name, x, y, sprite}
let npcSprites = {}; // id -> Image
let draggingNpc = null;
let npcDragOffsetX = 0;
let npcDragOffsetY = 0;
let isDraggingNpc = false;

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; // base tile size for editor

// ============================
// PALETTE GENERATION
// ============================
function buildPalette() {
  const palette = document.getElementById('palette');
  palette.innerHTML = '';
  const sorted = Object.entries(T).sort((a, b) => a[1] - b[1]);
  for (const [name, id] of sorted) {
    const btn = document.createElement('button');
    btn.className = 'tile-btn' + (id === selectedTile ? ' selected' : '');
    btn.dataset.tileId = id;
    btn.dataset.tileName = name.toLowerCase();

    const preview = document.createElement('canvas');
    preview.className = 'tile-preview';
    preview.width = 24;
    preview.height = 24;
    const pc = preview.getContext('2d');
    pc.fillStyle = TILE_COLORS[id] || '#333';
    pc.fillRect(0, 0, 24, 24);
    // Add a subtle inner border
    pc.strokeStyle = 'rgba(255,255,255,0.15)';
    pc.strokeRect(0.5, 0.5, 23, 23);

    const label = document.createElement('span');
    label.textContent = `${TILE_ICONS[id] || '‚ùì'} ${name} (${id})`;

    // Solid indicator
    const solidBadge = document.createElement('span');
    solidBadge.className = 'solid-badge';
    solidBadge.dataset.tileId = id;
    solidBadge.style.cssText = 'margin-left:auto; font-size:10px; padding:1px 4px; border-radius:3px; flex-shrink:0;';
    updateSolidBadge(solidBadge, id);

    btn.appendChild(preview);
    btn.appendChild(label);
    btn.appendChild(solidBadge);
    btn.onclick = () => selectTile(id);
    palette.appendChild(btn);
  }
}

function updateSolidBadge(badge, id) {
  if (blockedTiles.has(id)) {
    badge.textContent = 'üß±';
    badge.style.background = 'rgba(170,40,0,0.4)';
  } else {
    badge.textContent = 'üö∂';
    badge.style.background = 'rgba(0,120,60,0.3)';
  }
}

function refreshAllSolidBadges() {
  document.querySelectorAll('.solid-badge').forEach(b => {
    updateSolidBadge(b, +b.dataset.tileId);
  });
}

async function toggleSelectedTileSolid() {
  const id = selectedTile;
  if (blockedTiles.has(id)) {
    blockedTiles.delete(id);
  } else {
    blockedTiles.add(id);
  }
  refreshAllSolidBadges();
  renderMap();
  // Save to server
  try {
    await fetch('/api/editor/blocked', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ blocked: [...blockedTiles] })
    });
    showToast(blockedTiles.has(id) ? 'üß± Tile agora √© s√≥lido' : 'üö∂ Tile agora √© pass√°vel');
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

function selectTile(id) {
  selectedTile = id;
  document.querySelectorAll('.tile-btn').forEach(b => {
    b.classList.toggle('selected', +b.dataset.tileId === id);
  });
  const solidText = blockedTiles.has(id) ? ' [S√ìLIDO]' : '';
  document.getElementById('selectedInfo').textContent = `${TILE_NAMES[id]} (${id})${solidText}`;
}

function filterTiles(query) {
  const q = query.toLowerCase();
  document.querySelectorAll('.tile-btn').forEach(btn => {
    btn.style.display = btn.dataset.tileName.includes(q) ? '' : 'none';
  });
}

function setTool(tool) {
  currentTool = tool;
  document.querySelectorAll('#tools button').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('tool-' + tool);
  if (btn) btn.classList.add('active');
  rectStart = null;
  lineStart = null;
  // Show/hide panels
  document.getElementById('image-panel').style.display = (tool === 'image') ? 'block' : 'none';
  document.getElementById('collision-panel').style.display = (tool === 'collision') ? 'block' : 'none';
  document.getElementById('npc-panel').style.display = (tool === 'npc') ? 'block' : 'none';
  if (tool !== 'selectobj') {
    deselectObj();
  }
  if (tool === 'npc') {
    refreshNpcList();
  }
  if (tool === 'collision') {
    updateSolidCount();
  }
}

function toggleGrid() {
  showGrid = !showGrid;
  document.getElementById('grid-toggle').textContent = 'Grid: ' + (showGrid ? 'ON' : 'OFF');
  renderMap();
}

// ============================
// MAP LOADING / SAVING
// ============================
async function loadQuadrant(q) {
  currentQuadrant = q;
  try {
    const res = await fetch(`/api/editor/map/${q}`);
    const data = await res.json();
    mapData = data.map;
    mapW = data.width;
    mapH = data.height;
    mapObjects = data.objects || [];
    mapObjectImages = {};
    loadAllObjectImages();
    if (data.blockedTiles) {
      blockedTiles = new Set(data.blockedTiles);
      refreshAllSolidBadges();
    }
    // Load NPCs
    editorNpcs = data.npcs || [];
    loadNpcSprites();
    refreshNpcList();
    // Load per-cell solid grid
    solidCellSet = new Set(data.solidCells || []);
    updateSolidCount();
    document.getElementById('mapSize').textContent = `${mapW}x${mapH}`;
    undoStack = [];
    offsetX = 0;
    offsetY = 0;
    resizeCanvas();
    renderMap();
    showToast(`Mapa ${q} carregado!`);
  } catch (e) {
    showToast('Erro ao carregar mapa: ' + e.message);
  }
}

async function saveMap() {
  if (!mapData) return;
  try {
    const res = await fetch(`/api/editor/map/${currentQuadrant}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ map: mapData })
    });
    const data = await res.json();
    if (data.success) {
      showToast('‚úÖ Mapa salvo com sucesso!');
    } else {
      showToast('‚ùå Erro: ' + (data.error || 'Desconhecido'));
    }
  } catch (e) {
    showToast('‚ùå Erro ao salvar: ' + e.message);
  }
}

function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.style.display = 'block';
  setTimeout(() => { toast.style.display = 'none'; }, 2000);
}

// ============================
// UNDO SYSTEM
// ============================
function pushUndo(changes) {
  if (changes.length === 0) return;
  undoStack.push(changes);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undo() {
  if (undoStack.length === 0) return;
  const changes = undoStack.pop();
  for (const c of changes) {
    mapData[c.y][c.x] = c.oldTile;
  }
  renderMap();
  showToast('‚Ü© Desfeito');
}

// ============================
// PAINTING
// ============================
let currentUndoBatch = [];

function setTileAt(x, y, tileId) {
  if (x < 0 || y < 0 || x >= mapW || y >= mapH) return;
  if (mapData[y][x] === tileId) return;
  currentUndoBatch.push({ x, y, oldTile: mapData[y][x] });
  mapData[y][x] = tileId;
}

function paintAt(mx, my) {
  const { tx, ty } = screenToTile(mx, my);
  const half = Math.floor(brushSize / 2);
  const tile = currentTool === 'erase' ? T.GRASS : selectedTile;
  for (let dy = -half; dy < brushSize - half; dy++) {
    for (let dx = -half; dx < brushSize - half; dx++) {
      setTileAt(tx + dx, ty + dy, tile);
    }
  }
}

function floodFill(startX, startY, newTile) {
  if (startX < 0 || startY < 0 || startX >= mapW || startY >= mapH) return;
  const oldTile = mapData[startY][startX];
  if (oldTile === newTile) return;

  const stack = [[startX, startY]];
  const visited = new Set();
  let count = 0;
  const MAX_FILL = 10000;

  while (stack.length > 0 && count < MAX_FILL) {
    const [x, y] = stack.pop();
    const key = y * mapW + x;
    if (visited.has(key)) continue;
    if (x < 0 || y < 0 || x >= mapW || y >= mapH) continue;
    if (mapData[y][x] !== oldTile) continue;

    visited.add(key);
    setTileAt(x, y, newTile);
    count++;

    stack.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
  }
}

function drawRect(x1, y1, x2, y2, tileId) {
  const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
  const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
  for (let y = minY; y <= maxY; y++)
    for (let x = minX; x <= maxX; x++)
      setTileAt(x, y, tileId);
}

function drawLine(x1, y1, x2, y2, tileId) {
  const dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
  const sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
  let err = dx - dy;
  let x = x1, y = y1;
  while (true) {
    const half = Math.floor(brushSize / 2);
    for (let bdy = -half; bdy < brushSize - half; bdy++)
      for (let bdx = -half; bdx < brushSize - half; bdx++)
        setTileAt(x + bdx, y + bdy, tileId);
    if (x === x2 && y === y2) break;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x += sx; }
    if (e2 < dx) { err += dx; y += sy; }
  }
}

// ============================
// COORDINATE HELPERS
// ============================
function screenToTile(mx, my) {
  const rect = canvas.getBoundingClientRect();
  const px = (mx - rect.left) / zoom + offsetX;
  const py = (my - rect.top) / zoom + offsetY;
  return { tx: Math.floor(px / TILE_SIZE), ty: Math.floor(py / TILE_SIZE) };
}

// ============================
// RENDERING
// ============================
function resizeCanvas() {
  const area = document.getElementById('canvas-area');
  canvas.width = area.clientWidth;
  canvas.height = area.clientHeight;
}

function renderMap() {
  if (!mapData) return;
  ctx.imageSmoothingEnabled = false;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(-offsetX, -offsetY);

  // Visible range
  const startTX = Math.max(0, Math.floor(offsetX / TILE_SIZE));
  const startTY = Math.max(0, Math.floor(offsetY / TILE_SIZE));
  const endTX = Math.min(mapW, Math.ceil((offsetX + canvas.width / zoom) / TILE_SIZE) + 1);
  const endTY = Math.min(mapH, Math.ceil((offsetY + canvas.height / zoom) / TILE_SIZE) + 1);

  for (let ty = startTY; ty < endTY; ty++) {
    for (let tx = startTX; tx < endTX; tx++) {
      const tile = mapData[ty][tx];
      const sx = tx * TILE_SIZE;
      const sy = ty * TILE_SIZE;

      // Fill tile color
      ctx.fillStyle = TILE_COLORS[tile] || '#ff00ff';
      ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);

      // Add subtle detail marks for certain tiles
      if (tile === T.TREE) {
        ctx.fillStyle = '#143d08';
        ctx.fillRect(sx + 3, sy + 3, 10, 10);
        ctx.fillStyle = '#1d5a0e';
        ctx.fillRect(sx + 4, sy + 4, 8, 8);
      } else if (tile === T.WATER) {
        ctx.fillStyle = '#3070d0';
        ctx.fillRect(sx + 2, sy + 6, 12, 2);
        ctx.fillRect(sx + 5, sy + 10, 8, 2);
      } else if (tile === T.WELL) {
        ctx.fillStyle = '#333';
        ctx.fillRect(sx + 2, sy + 2, 12, 12);
        ctx.fillStyle = '#2060c0';
        ctx.fillRect(sx + 4, sy + 4, 8, 8);
      } else if (tile === T.FLOWERS) {
        ctx.fillStyle = '#ff6688';
        ctx.fillRect(sx + 3, sy + 4, 2, 2);
        ctx.fillRect(sx + 9, sy + 7, 2, 2);
        ctx.fillRect(sx + 6, sy + 10, 2, 2);
      } else if (tile === T.GRAVESTONE) {
        ctx.fillStyle = '#aaa';
        ctx.fillRect(sx + 4, sy + 3, 8, 10);
        ctx.fillStyle = '#999';
        ctx.fillRect(sx + 4, sy + 3, 8, 2);
      } else if (tile === T.CROSS) {
        ctx.fillStyle = '#c09030';
        ctx.fillRect(sx + 7, sy + 2, 2, 12);
        ctx.fillRect(sx + 4, sy + 5, 8, 2);
      } else if (tile === T.TORCH_WALL) {
        ctx.fillStyle = '#ffcc00';
        ctx.fillRect(sx + 6, sy + 2, 4, 4);
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(sx + 7, sy + 1, 2, 3);
      } else if (tile === T.WINDOW_STONE || tile === T.WINDOW_WOOD) {
        ctx.fillStyle = '#aaddff';
        ctx.fillRect(sx + 3, sy + 3, 10, 10);
        ctx.fillStyle = tile === T.WINDOW_STONE ? '#555' : '#5a3818';
        ctx.fillRect(sx + 7, sy + 3, 2, 10);
        ctx.fillRect(sx + 3, sy + 7, 10, 2);
      }

      // Blocked tile overlay
      if (showBlockedOverlay && blockedTiles.has(tile)) {
        ctx.fillStyle = 'rgba(255,0,0,0.18)';
        ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
        // Small X mark
        ctx.strokeStyle = 'rgba(255,60,60,0.5)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(sx + 2, sy + 2); ctx.lineTo(sx + TILE_SIZE - 2, sy + TILE_SIZE - 2);
        ctx.moveTo(sx + TILE_SIZE - 2, sy + 2); ctx.lineTo(sx + 2, sy + TILE_SIZE - 2);
        ctx.stroke();
      }

      // Grid
      if (showGrid && zoom >= 0.5) {
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.strokeRect(sx + 0.5, sy + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
      }
    }
  }

  // Draw image objects
  drawObjects();

  // Draw per-cell solid overlay
  if (showCollisionOverlay && solidCellSet.size > 0) {
    for (const key of solidCellSet) {
      const [cx, cy] = key.split(',').map(Number);
      if (cx < startTX || cx >= endTX || cy < startTY || cy >= endTY) continue;
      const sx = cx * TILE_SIZE;
      const sy = cy * TILE_SIZE;
      ctx.fillStyle = 'rgba(255,100,0,0.3)';
      ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
      // Diagonal lines pattern
      ctx.strokeStyle = 'rgba(255,100,0,0.6)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy); ctx.lineTo(sx + TILE_SIZE, sy + TILE_SIZE);
      ctx.moveTo(sx + TILE_SIZE, sy); ctx.lineTo(sx, sy + TILE_SIZE);
      ctx.stroke();
    }
  }

  // Draw NPCs
  if (showNpcOverlay) {
    drawEditorNpcs();
  }

  // Draw brush preview
  if (lastMouseTile) {
    const half = Math.floor(brushSize / 2);
    ctx.strokeStyle = '#e94560';
    ctx.lineWidth = 1 / zoom;
    for (let dy = -half; dy < brushSize - half; dy++) {
      for (let dx = -half; dx < brushSize - half; dx++) {
        const bx = (lastMouseTile.tx + dx) * TILE_SIZE;
        const by = (lastMouseTile.ty + dy) * TILE_SIZE;
        ctx.strokeRect(bx + 0.5, by + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
      }
    }
  }

  ctx.restore();
}

let lastMouseTile = null;

// ============================
// EVENT HANDLING
// ============================
canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('mousedown', (e) => {
  if (!mapData) return;

  const { tx, ty } = screenToTile(e.clientX, e.clientY);

  // Collision tool: right-click = add solid, left-click = remove solid
  if (currentTool === 'collision') {
    if (e.button === 2) {
      // Right click = add solid
      isCollisionPainting = true;
      collisionPaintMode = 'add';
      paintCollision(tx, ty, 'add');
      renderMap();
      return;
    }
    if (e.button === 0 && !e.altKey) {
      // Left click = remove solid
      isCollisionPainting = true;
      collisionPaintMode = 'remove';
      paintCollision(tx, ty, 'remove');
      renderMap();
      return;
    }
    if (e.button === 0 && e.altKey) {
      // Alt+Click = pan
      isPanning = true;
      panStartX = e.clientX;
      panStartY = e.clientY;
      return;
    }
  }

  // NPC tool: drag NPCs
  if (currentTool === 'npc' && e.button === 0 && !e.altKey) {
    const clickedNpc = editorNpcs.find(n => {
      const nx = Math.floor(n.x);
      const ny = Math.floor(n.y);
      return tx >= nx - 1 && tx <= nx + 1 && ty >= ny - 1 && ty <= ny + 1;
    });
    if (clickedNpc) {
      draggingNpc = clickedNpc;
      isDraggingNpc = true;
      npcDragOffsetX = tx - Math.floor(clickedNpc.x);
      npcDragOffsetY = ty - Math.floor(clickedNpc.y);
      return;
    }
  }

  if (e.button === 2 || (e.button === 0 && e.altKey)) {
    // Right click or Alt+Click = pan
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    return;
  }

  if (e.button === 0) {
    const { tx, ty } = screenToTile(e.clientX, e.clientY);

    if (currentTool === 'image') {
      placeImageObject(tx, ty);
      return;
    }

    if (currentTool === 'selectobj') {
      const clicked = mapObjects.find(o => tx >= o.x && tx < o.x + o.width && ty >= o.y && ty < o.y + o.height);
      if (clicked) {
        selectObj(clicked);
        isDraggingObj = true;
        dragObjOffsetX = tx - clicked.x;
        dragObjOffsetY = ty - clicked.y;
      } else {
        deselectObj();
      }
      return;
    }

    if (currentTool === 'pick') {
      // Eyedropper
      if (tx >= 0 && ty >= 0 && tx < mapW && ty < mapH) {
        selectTile(mapData[ty][tx]);
        setTool('paint');
      }
      return;
    }

    if (currentTool === 'fill') {
      currentUndoBatch = [];
      floodFill(tx, ty, selectedTile);
      pushUndo(currentUndoBatch);
      renderMap();
      return;
    }

    if (currentTool === 'rect') {
      if (!rectStart) {
        rectStart = { tx, ty };
      } else {
        currentUndoBatch = [];
        drawRect(rectStart.tx, rectStart.ty, tx, ty, selectedTile);
        pushUndo(currentUndoBatch);
        rectStart = null;
        renderMap();
      }
      return;
    }

    if (currentTool === 'line') {
      if (!lineStart) {
        lineStart = { tx, ty };
      } else {
        currentUndoBatch = [];
        drawLine(lineStart.tx, lineStart.ty, tx, ty, selectedTile);
        pushUndo(currentUndoBatch);
        lineStart = null;
        renderMap();
      }
      return;
    }

    // Paint / Erase
    isPainting = true;
    currentUndoBatch = [];
    paintAt(e.clientX, e.clientY);
    renderMap();
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (!mapData) return;

  const { tx, ty } = screenToTile(e.clientX, e.clientY);
  lastMouseTile = { tx, ty };
  document.getElementById('coords').textContent = `X: ${tx}, Y: ${ty} | Tile: ${TILE_NAMES[mapData?.[ty]?.[tx]] || '?'}${solidCellSet.has(`${tx},${ty}`) ? ' [S√ìLIDO]' : ''}`;

  if (isPanning) {
    const dx = e.clientX - panStartX;
    const dy = e.clientY - panStartY;
    offsetX -= dx / zoom;
    offsetY -= dy / zoom;
    panStartX = e.clientX;
    panStartY = e.clientY;
    renderMap();
    return;
  }

  // Collision painting drag
  if (isCollisionPainting && collisionPaintMode) {
    paintCollision(tx, ty, collisionPaintMode);
    renderMap();
    return;
  }

  // NPC dragging
  if (isDraggingNpc && draggingNpc) {
    const newX = tx - npcDragOffsetX;
    const newY = ty - npcDragOffsetY;
    if (newX !== Math.floor(draggingNpc.x) || newY !== Math.floor(draggingNpc.y)) {
      draggingNpc.x = Math.max(0, Math.min(mapW - 1, newX));
      draggingNpc.y = Math.max(0, Math.min(mapH - 1, newY));
      renderMap();
    }
    return;
  }

  if (isDraggingObj && selectedObj) {
    const newX = tx - dragObjOffsetX;
    const newY = ty - dragObjOffsetY;
    if (newX !== selectedObj.x || newY !== selectedObj.y) {
      selectedObj.x = Math.max(0, Math.min(mapW - selectedObj.width, newX));
      selectedObj.y = Math.max(0, Math.min(mapH - selectedObj.height, newY));
      document.getElementById('objX').value = selectedObj.x;
      document.getElementById('objY').value = selectedObj.y;
      renderMap();
    }
    return;
  }

  if (isPainting) {
    paintAt(e.clientX, e.clientY);
    renderMap();
  } else {
    renderMap(); // update brush preview
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (isPanning) {
    isPanning = false;
    return;
  }
  if (isCollisionPainting) {
    isCollisionPainting = false;
    collisionPaintMode = null;
    saveSolidCells();
    return;
  }
  if (isDraggingNpc && draggingNpc) {
    isDraggingNpc = false;
    saveNpcPosition(draggingNpc);
    draggingNpc = null;
    return;
  }
  if (isDraggingObj && selectedObj) {
    isDraggingObj = false;
    saveSelectedObjToServer();
    return;
  }
  if (isPainting) {
    isPainting = false;
    pushUndo(currentUndoBatch);
    currentUndoBatch = [];
  }
});

canvas.addEventListener('mouseleave', () => {
  isPanning = false;
  if (isCollisionPainting) {
    isCollisionPainting = false;
    collisionPaintMode = null;
    saveSolidCells();
  }
  if (isDraggingNpc && draggingNpc) {
    isDraggingNpc = false;
    saveNpcPosition(draggingNpc);
    draggingNpc = null;
  }
  if (isDraggingObj && selectedObj) {
    isDraggingObj = false;
    saveSelectedObjToServer();
  }
  if (isPainting) {
    isPainting = false;
    pushUndo(currentUndoBatch);
    currentUndoBatch = [];
  }
  lastMouseTile = null;
  renderMap();
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const { tx, ty } = screenToTile(e.clientX, e.clientY);
  const oldZoom = zoom;

  if (e.deltaY < 0) zoom = Math.min(zoom * 1.15, 8);
  else zoom = Math.max(zoom / 1.15, 0.2);

  // Zoom toward mouse position
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  offsetX = (offsetX + mx / oldZoom) - mx / zoom;
  offsetY = (offsetY + my / oldZoom) - my / zoom;

  renderMap();
}, { passive: false });

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;

  if (e.ctrlKey && e.key === 'z') { undo(); e.preventDefault(); }
  if (e.key === 'g' || e.key === 'G') toggleGrid();
  if (e.key === 'e' || e.key === 'E') setTool('pick');
  if (e.key === 'f' || e.key === 'F') setTool('fill');
  if (e.key === 'b' || e.key === 'B') setTool('paint');
  if (e.key === 'r' || e.key === 'R') setTool('rect');
  if (e.key === 'l' || e.key === 'L') setTool('line');
  if (e.key === 'x' || e.key === 'X') setTool('erase');
  if (e.key === 'i' || e.key === 'I') setTool('image');
  if (e.key === 's' || e.key === 'S') setTool('selectobj');
  if (e.key === 'n' || e.key === 'N') setTool('npc');
  if (e.key === 'c' || e.key === 'C') setTool('collision');
  if (e.key === 'Delete' && selectedObj) deleteSelectedObj();

  // Number keys for brush size
  if (e.key >= '1' && e.key <= '9') {
    brushSize = +e.key;
    document.getElementById('brushRange').value = brushSize;
    document.getElementById('brushVal').textContent = brushSize;
    renderMap();
  }
});

// Window resize
window.addEventListener('resize', () => {
  resizeCanvas();
  renderMap();
});

// ============================
// IMAGE OBJECTS SYSTEM
// ============================
let mapObjects = []; // {id, src, x, y, width, height}
let mapObjectImages = {}; // id -> Image
let pendingImageData = null; // base64 data URL ready to place
let selectedObj = null;
let isDraggingObj = false;
let dragObjOffsetX = 0;
let dragObjOffsetY = 0;

function onImageSelected(input) {
  if (!input.files || !input.files[0]) return;
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = (e) => {
    pendingImageData = e.target.result;
    const preview = document.getElementById('imgPreview');
    preview.innerHTML = `<img src="${pendingImageData}" style="max-width:100%; max-height:80px; border:1px solid #555; border-radius:3px;">`;
    showToast('Clique no mapa para posicionar a imagem');
  };
  reader.readAsDataURL(file);
}

async function placeImageObject(tx, ty) {
  if (!pendingImageData) { showToast('Selecione uma imagem primeiro'); return; }
  const w = +document.getElementById('imgW').value || 3;
  const h = +document.getElementById('imgH').value || 3;
  try {
    const res = await fetch(`/api/editor/objects/${currentQuadrant}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ src: pendingImageData, x: tx, y: ty, width: w, height: h })
    });
    const data = await res.json();
    if (data.success) {
      mapObjects.push(data.object);
      loadObjectImage(data.object);
      showToast('‚úÖ Imagem posicionada!');
      renderMap();
    } else {
      showToast('‚ùå Erro: ' + (data.error || '?'));
    }
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

function selectObj(obj) {
  selectedObj = obj;
  document.getElementById('obj-panel').style.display = 'block';
  document.getElementById('objX').value = obj.x;
  document.getElementById('objY').value = obj.y;
  document.getElementById('objW').value = obj.width;
  document.getElementById('objH').value = obj.height;
  const preview = document.getElementById('objPreview');
  const img = mapObjectImages[obj.id];
  if (img) {
    preview.innerHTML = `<img src="${img.src}" style="max-width:100%; max-height:60px; border:1px solid #555; border-radius:3px;">`;
  } else {
    preview.innerHTML = '<span style="color:#888">Sem preview</span>';
  }
  renderMap();
}

function deselectObj() {
  selectedObj = null;
  isDraggingObj = false;
  document.getElementById('obj-panel').style.display = 'none';
  renderMap();
}

async function updateSelectedObjProps() {
  if (!selectedObj) return;
  selectedObj.x = +document.getElementById('objX').value;
  selectedObj.y = +document.getElementById('objY').value;
  selectedObj.width = +document.getElementById('objW').value || 1;
  selectedObj.height = +document.getElementById('objH').value || 1;
  renderMap();
  await saveSelectedObjToServer();
}

async function saveSelectedObjToServer() {
  if (!selectedObj) return;
  try {
    await fetch(`/api/editor/objects/${currentQuadrant}/${selectedObj.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ x: selectedObj.x, y: selectedObj.y, width: selectedObj.width, height: selectedObj.height })
    });
  } catch (e) {
    showToast('‚ùå Erro ao salvar: ' + e.message);
  }
}

async function deleteSelectedObj() {
  if (!selectedObj) return;
  try {
    const res = await fetch(`/api/editor/objects/${currentQuadrant}/${selectedObj.id}`, { method: 'DELETE' });
    const data = await res.json();
    if (data.success) {
      mapObjects = mapObjects.filter(o => o.id !== selectedObj.id);
      delete mapObjectImages[selectedObj.id];
      deselectObj();
      showToast('üóëÔ∏è Objeto removido!');
    }
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

function loadObjectImage(obj) {
  if (!mapObjectImages[obj.id]) {
    const img = new Image();
    img.onload = () => renderMap();
    img.src = obj.src;
    mapObjectImages[obj.id] = img;
  }
}

function loadAllObjectImages() {
  for (const obj of mapObjects) loadObjectImage(obj);
}

function drawObjects() {
  for (const obj of mapObjects) {
    const img = mapObjectImages[obj.id];
    const sx = obj.x * TILE_SIZE;
    const sy = obj.y * TILE_SIZE;
    const sw = obj.width * TILE_SIZE;
    const sh = obj.height * TILE_SIZE;
    if (img && img.complete && img.naturalWidth) {
      ctx.drawImage(img, sx, sy, sw, sh);
    } else {
      // Placeholder
      ctx.fillStyle = 'rgba(128,0,255,0.3)';
      ctx.fillRect(sx, sy, sw, sh);
      ctx.strokeStyle = '#a040ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(sx + 0.5, sy + 0.5, sw - 1, sh - 1);
    }
    // Border indicator
    const isSelected = selectedObj && obj.id === selectedObj.id;
    ctx.strokeStyle = isSelected ? 'rgba(0,255,255,1)' : 'rgba(255,255,0,0.5)';
    ctx.lineWidth = isSelected ? 2 : 0.5;
    ctx.setLineDash(isSelected ? [4,3] : [2,2]);
    ctx.strokeRect(sx, sy, sw, sh);
    ctx.setLineDash([]);
    if (isSelected) {
      // Draw resize handles at corners
      const hs = 3;
      ctx.fillStyle = '#0ff';
      ctx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
      ctx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
      ctx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
      ctx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
    }
  }
}

// ============================
// INIT
// ============================
buildPalette();
resizeCanvas();
// Center view
offsetX = 0;
offsetY = 0;
zoom = 2;
loadQuadrant('E5');
</script>
</body>
</html>
