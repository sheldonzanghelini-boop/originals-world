<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Originals World - Editor de Mapa</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }

/* Sidebar */
#sidebar {
  width: 260px;
  background: #16213e;
  border-right: 2px solid #0f3460;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
#sidebar h2 {
  padding: 12px;
  text-align: center;
  background: #0f3460;
  font-size: 15px;
  letter-spacing: 1px;
}
#tools {
  padding: 8px;
  border-bottom: 1px solid #0f3460;
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}
#tools button {
  padding: 6px 10px;
  background: #1a1a40;
  color: #ccc;
  border: 1px solid #333;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}
#tools button:hover { background: #2a2a60; }
#tools button.active { background: #e94560; color: #fff; border-color: #e94560; }
#brush-size {
  padding: 6px 8px;
  display: flex;
  align-items: center;
  gap: 6px;
  border-bottom: 1px solid #0f3460;
  font-size: 12px;
}
#brush-size input { width: 50px; }
#search-box {
  padding: 6px 8px;
  border-bottom: 1px solid #0f3460;
}
#search-box input {
  width: 100%;
  padding: 5px 8px;
  background: #1a1a40;
  color: #eee;
  border: 1px solid #333;
  border-radius: 4px;
  font-size: 12px;
}
#palette {
  flex: 1;
  overflow-y: auto;
  padding: 4px;
}
.tile-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  width: calc(100% - 4px);
  margin: 2px;
  padding: 4px 6px;
  background: #1a1a40;
  border: 2px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  color: #ccc;
  font-size: 11px;
  text-align: left;
}
.tile-btn:hover { background: #2a2a60; }
.tile-btn.selected { border-color: #e94560; background: #2a1a30; }
.tile-preview {
  width: 24px;
  height: 24px;
  border: 1px solid #444;
  border-radius: 2px;
  flex-shrink: 0;
}
#status-bar {
  padding: 8px;
  background: #0f3460;
  font-size: 11px;
  display: flex;
  justify-content: space-between;
}

/* Canvas area */
#canvas-area {
  flex: 1;
  position: relative;
  overflow: hidden;
}
#mapCanvas {
  position: absolute;
  top: 0;
  left: 0;
  image-rendering: pixelated;
}
#coords {
  position: absolute;
  top: 8px;
  left: 8px;
  background: rgba(0,0,0,0.7);
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 12px;
  pointer-events: none;
}
#help-overlay {
  position: absolute;
  bottom: 8px;
  left: 8px;
  background: rgba(0,0,0,0.7);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 11px;
  pointer-events: none;
  line-height: 1.6;
}
#quadrant-select {
  position: absolute;
  top: 8px;
  right: 8px;
  background: rgba(0,0,0,0.7);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  display: flex;
  gap: 6px;
  align-items: center;
}
#quadrant-select select {
  background: #1a1a40;
  color: #eee;
  border: 1px solid #444;
  padding: 3px 6px;
  border-radius: 3px;
}
#save-btn {
  position: absolute;
  top: 8px;
  right: 200px;
  padding: 6px 16px;
  background: #27ae60;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  font-weight: bold;
}
#save-btn:hover { background: #2ecc71; }
#undo-btn {
  position: absolute;
  top: 8px;
  right: 300px;
  padding: 6px 12px;
  background: #e67e22;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
}
#undo-btn:hover { background: #f39c12; }
#grid-toggle {
  position: absolute;
  top: 44px;
  right: 8px;
  padding: 4px 10px;
  background: rgba(0,0,0,0.7);
  color: #aaa;
  border: 1px solid #555;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
}
#toast {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(39,174,96,0.9);
  color: #fff;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: bold;
  display: none;
  pointer-events: none;
  z-index: 100;
}
</style>
</head>
<body>

<div id="sidebar">
  <h2>üó∫Ô∏è EDITOR DE MAPA</h2>
  <div id="tools">
    <button id="tool-paint" class="active" onclick="setTool('paint')">üñåÔ∏è Pintar</button>
    <button id="tool-erase" onclick="setTool('erase')">üßπ Apagar</button>
    <button id="tool-fill" onclick="setTool('fill')">ü™£ Preencher</button>
    <button id="tool-pick" onclick="setTool('pick')">üíâ Pegar</button>
    <button id="tool-rect" onclick="setTool('rect')">‚¨ú Ret√¢ngulo</button>
    <button id="tool-line" onclick="setTool('line')">üìè Linha</button>
    <button id="tool-image" onclick="setTool('image')">üñºÔ∏è Imagem</button>
    <button id="tool-selectobj" onclick="setTool('selectobj')">‚úã Selec Obj</button>
    <button id="tool-npc" onclick="setTool('npc')" style="background:#1a3a40;">üë§ NPCs</button>
    <button id="tool-spawn" onclick="setTool('spawn')" style="background:#3a1a40;">üëæ Spawns</button>
    <button id="tool-collision" onclick="setTool('collision')" style="background:#401a1a;">üß± Colis√£o</button>
    <button id="tool-behind" onclick="setTool('behind')" style="background:#1a1a40;">üî≤ Atr√°s</button>
  </div>
  <div id="brush-size">
    <label>Pincel:</label>
    <input type="range" id="brushRange" min="1" max="10" value="1" oninput="brushSize=+this.value; document.getElementById('brushVal').textContent=this.value">
    <span id="brushVal">1</span>
  </div>
  <div id="solid-toggle" style="padding:4px 8px; border-bottom:1px solid #0f3460; display:flex; align-items:center; gap:6px;">
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showSolids" checked onchange="showBlockedOverlay=this.checked; renderMap()">
      <span>Mostrar s√≥lidos</span>
    </label>
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showCollision" checked onchange="showCollisionOverlay=this.checked; renderMap()">
      <span>Mostrar colis√£o</span>
    </label>
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showNpcs" checked onchange="showNpcOverlay=this.checked; renderMap()">
      <span>Mostrar NPCs</span>
    </label>
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showSpawns" checked onchange="showSpawnOverlay=this.checked; renderMap()">
      <span>Mostrar Spawns</span>
    </label>
    <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="showBehind" checked onchange="showBehindOverlay=this.checked; renderMap()">
      <span>Mostrar Atr√°s</span>
    </label>
  </div>
  <div id="collision-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none; background:#2a1515;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üß± Ferramenta de Colis√£o</div>
    <div style="font-size:11px; color:#ccc; line-height:1.5;">
      <b>Bot√£o Direito</b> = marcar s√≥lido<br>
      <b>Bot√£o Esquerdo</b> = remover s√≥lido<br>
      Use o pincel para controlar o tamanho.
    </div>
    <div style="font-size:10px; color:#888; margin-top:4px;">C√©lulas s√≥lidas: <span id="solidCount">0</span></div>
  </div>
  <div id="behind-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none; background:#15152a;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üî≤ Ferramenta Passar por Tr√°s</div>
    <div style="font-size:11px; color:#ccc; line-height:1.5;">
      <b>Bot√£o Direito</b> = marcar "atr√°s"<br>
      <b>Bot√£o Esquerdo</b> = remover "atr√°s"<br>
      Tiles marcados fazem o jogador passar por tr√°s da imagem.
    </div>
    <div style="font-size:10px; color:#888; margin-top:4px;">C√©lulas atr√°s: <span id="behindCount">0</span></div>
  </div>
  <div id="npc-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none; background:#152a2a;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üë§ NPCs do Quadrante</div>
    <div id="npc-list" style="font-size:11px;"></div>
    <div style="font-size:10px; color:#888; margin-top:4px;">Arraste os NPCs no mapa para reposicionar.</div>
  </div>
  <div id="spawn-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none; background:#2a152a;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üëæ Spawns de Mobs</div>
    <div style="display:flex; gap:4px; margin:4px 0; align-items:center;">
      <label style="font-size:11px;">Tipo:</label>
      <select id="spawnType" style="flex:1; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;">
        <option value="skeleton">üíÄ Esqueleto</option>
        <option value="slime">üü¢ Slime</option>
        <option value="zombie">üßü Zumbi</option>
      </select>
    </div>
    <div style="display:flex; gap:4px; margin:4px 0; align-items:center;">
      <label style="font-size:11px;">Qtd:</label>
      <input type="number" id="spawnCount" value="4" min="1" max="20" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;">
      <label style="font-size:11px;">Raio:</label>
      <input type="number" id="spawnRadius" value="5" min="1" max="20" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;">
    </div>
    <div style="font-size:10px; color:#888; margin:4px 0;">Clique no mapa para criar spawn. Arraste para mover.</div>
    <div id="spawn-list" style="font-size:11px; max-height:150px; overflow-y:auto;"></div>
    <div id="spawn-sel-panel" style="display:none; margin-top:6px; border-top:1px solid #555; padding-top:6px;">
      <div style="font-size:11px; font-weight:bold; margin-bottom:4px;">Spawn Selecionado</div>
      <div style="display:flex; gap:4px; align-items:center; margin:2px 0;">
        <label style="font-size:10px;">Tipo:</label>
        <select id="selSpawnType" style="flex:1; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px; font-size:10px;" onchange="updateSelectedSpawn()">
          <option value="skeleton">üíÄ Esqueleto</option>
          <option value="slime">üü¢ Slime</option>
          <option value="zombie">üßü Zumbi</option>
        </select>
      </div>
      <div style="display:flex; gap:4px; align-items:center; margin:2px 0;">
        <label style="font-size:10px;">Qtd:</label>
        <input type="number" id="selSpawnCount" min="1" max="20" style="width:35px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px; font-size:10px;" onchange="updateSelectedSpawn()">
        <label style="font-size:10px;">Raio:</label>
        <input type="number" id="selSpawnRadius" min="1" max="20" style="width:35px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px; font-size:10px;" onchange="updateSelectedSpawn()">
      </div>
      <div style="display:flex; gap:4px; margin-top:4px;">
        <button onclick="deleteSelectedSpawn()" style="flex:1; padding:3px 6px; background:#aa2020; color:#fff; border:none; border-radius:3px; cursor:pointer; font-size:10px;">üóëÔ∏è Deletar</button>
        <button onclick="deselectSpawn()" style="flex:1; padding:3px 6px; background:#555; color:#fff; border:none; border-radius:3px; cursor:pointer; font-size:10px;">‚úñ Deselecionar</button>
      </div>
    </div>
  </div>
  <div id="image-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none;">
    <label style="font-size:12px;">Imagem:</label>
    <input type="file" id="imageFile" accept="image/*" style="width:100%; margin:4px 0; font-size:11px; color:#ccc;" onchange="onImageSelected(this)">
    <div style="display:flex; gap:4px; margin:4px 0;">
      <label style="font-size:11px;">Larg (tiles):</label>
      <input type="number" id="imgW" value="3" min="1" max="50" style="width:45px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;">
      <label style="font-size:11px;">Alt:</label>
      <input type="number" id="imgH" value="3" min="1" max="50" style="width:45px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;">
    </div>
    <div id="imgPreview" style="max-width:100%; max-height:80px; margin:4px 0; text-align:center;"></div>
    <div style="font-size:10px; color:#888;">Clique no mapa para posicionar</div>
  </div>
  <div id="obj-panel" style="padding:6px 8px; border-bottom:1px solid #0f3460; display:none;">
    <div style="font-size:12px; font-weight:bold; margin-bottom:4px;">üì¶ Objeto Selecionado</div>
    <div id="objPreview" style="max-width:100%; max-height:60px; margin:4px 0; text-align:center;"></div>
    <div style="display:flex; gap:4px; margin:4px 0; align-items:center;">
      <label style="font-size:11px;">X:</label>
      <input type="number" id="objX" min="0" max="99" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateSelectedObjProps()">
      <label style="font-size:11px;">Y:</label>
      <input type="number" id="objY" min="0" max="99" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateSelectedObjProps()">
    </div>
    <div style="display:flex; gap:4px; margin:4px 0; align-items:center;">
      <label style="font-size:11px;">Larg:</label>
      <input type="number" id="objW" min="1" max="50" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateObjWidth()">
      <label style="font-size:11px;">Alt:</label>
      <input type="number" id="objH" min="1" max="50" style="width:40px; background:#1a1a40; color:#eee; border:1px solid #333; border-radius:3px; padding:2px 4px; font-size:11px;" onchange="updateObjHeight()">
    </div>
    <div style="display:flex; gap:4px; margin-top:6px;">
      <button onclick="deleteSelectedObj()" style="flex:1; padding:4px 8px; background:#aa2020; color:#fff; border:none; border-radius:3px; cursor:pointer; font-size:11px;">üóëÔ∏è Deletar</button>
      <button onclick="deselectObj()" style="flex:1; padding:4px 8px; background:#555; color:#fff; border:none; border-radius:3px; cursor:pointer; font-size:11px;">‚úñ Deselecionar</button>
    </div>
    <div style="font-size:10px; color:#888; margin-top:4px;">Arraste para mover no mapa</div>
  </div>
  <div id="search-box">
    <input type="text" id="tileSearch" placeholder="Buscar tile..." oninput="filterTiles(this.value)">
  </div>
  <div id="palette"></div>
  <div id="status-bar">
    <span id="selectedInfo">GRASS (0)</span>
    <span id="mapSize">100x100</span>
  </div>
</div>

<div id="canvas-area">
  <canvas id="mapCanvas"></canvas>
  <div id="coords">X: 0, Y: 0</div>
  <div id="help-overlay">
    Scroll = Zoom | Arrastar Direito = Mover<br>
    Click Esq = Pintar | Ctrl+Z = Desfazer<br>
    E = Pegar tile | G = Grid | F = Preencher<br>
    I = Imagem | S = Selec Objeto<br>
    N = NPCs | M = Spawns | C = Colis√£o (Dir=S√≥lido, Esq=Normal)
  </div>
  <div id="quadrant-select">
    <label>Mapa:</label>
    <select id="quadSelect" onchange="loadQuadrant(this.value)">
      <option value="E5">E5 - Vila de Testes</option>
      <option value="E4">E4 - Plan√≠cie</option>
      <option value="F5">F5 - Cidade</option>
      <option value="IGREJA">IGREJA - Interior da Igreja</option>
    </select>
  </div>
  <button id="save-btn" onclick="saveMap()">üíæ Salvar</button>
  <button id="undo-btn" onclick="undo()">‚Ü© Desfazer</button>
  <button id="grid-toggle" onclick="toggleGrid()">Grid: ON</button>
  <div id="toast"></div>
</div>

<script>
// ============================
// TILE DEFINITIONS
// ============================
const T = {
  GRASS:0, DIRT:1, STONE_PATH:2, STONE_WALL:3, WATER:4, TREE_CARVALHO:5, WOOD_FLOOR:6,
  CHURCH_FLOOR:7, WOOD_WALL:8, SAND:9, FLOWERS:10, BUSH:11, ROCK:12,
  RED_CARPET:13, ALTAR:14, ANVIL:15, FURNACE:16, BOOKSHELF:17, TABLE:18,
  CHAIR:19, WELL:20, FENCE:21, ROOF_STONE:22, ROOF_WOOD:23, WINDOW_STONE:24,
  WINDOW_WOOD:25, CROSS:26, TALL_GRASS:27, MUSHROOM:28, BARREL:29, CRATE:30,
  TORCH_WALL:31, BED:32, RUG:33, CHURCH_PEW:34, DARK_GRASS:35,
  GRAVESTONE:36, DEAD_TREE:37, BONE:38, MUD:39, HAY:40, CHURCH_WALL:41,
  ROOF_RED:42, ROOF_BLUE:43, ROOF_YELLOW:44, BENCH:45,
  TREE_BETULA:46, TREE_CARVALHO_SMALL:47, TREE_MAGICA:48, TREE_MANGUE:49, TREE_PINHEIRO:50, TREE_PINOS:51,
  WATER_RIVER:52
};

// Color map for rendering tiles on the editor
const TILE_COLORS = {
  [T.GRASS]: '#3a7a2c',
  [T.DARK_GRASS]: '#2a5c18',
  [T.TALL_GRASS]: '#4a9a3a',
  [T.FLOWERS]: '#5a8c4f',
  [T.MUSHROOM]: '#3a7a2c',
  [T.BUSH]: '#1e5c10',
  [T.ROCK]: '#888',
  [T.DIRT]: '#8b6b3d',
  [T.STONE_PATH]: '#999',
  [T.STONE_WALL]: '#666',
  [T.WATER]: '#2060c0',
  [T.WATER_RIVER]: '#3a90d8',
  [T.TREE_CARVALHO]: '#1d4b0e',
  [T.WOOD_FLOOR]: '#a07850',
  [T.CHURCH_FLOOR]: '#b0a880',
  [T.RED_CARPET]: '#aa2020',
  [T.ALTAR]: '#ddd',
  [T.CROSS]: '#d4a750',
  [T.CHURCH_PEW]: '#6a4020',
  [T.BOOKSHELF]: '#5a3a1a',
  [T.WOOD_WALL]: '#6a4420',
  [T.WINDOW_STONE]: '#66aadd',
  [T.WINDOW_WOOD]: '#88bbdd',
  [T.TABLE]: '#8a6040',
  [T.CHAIR]: '#7a5030',
  [T.WELL]: '#556',
  [T.FENCE]: '#8a6530',
  [T.ROOF_STONE]: '#606060',
  [T.ROOF_WOOD]: '#7a4828',
  [T.SAND]: '#d4c080',
  [T.ANVIL]: '#555',
  [T.FURNACE]: '#884422',
  [T.BARREL]: '#7a5020',
  [T.CRATE]: '#8a6530',
  [T.TORCH_WALL]: '#ff8800',
  [T.BED]: '#884444',
  [T.RUG]: '#993333',
  [T.MUD]: '#5a4020',
  [T.HAY]: '#c8a830',
  [T.GRAVESTONE]: '#888',
  [T.DEAD_TREE]: '#3a2a10',
  [T.BONE]: '#ddd8c0',
  [T.CHURCH_WALL]: '#777788',
  [T.ROOF_RED]: '#aa2020',
  [T.ROOF_BLUE]: '#2050aa',
  [T.ROOF_YELLOW]: '#c8a020',
  [T.BENCH]: '#8a6a40',
  [T.TREE_BETULA]: '#e8e0c0',
  [T.TREE_CARVALHO_SMALL]: '#4a8a30',
  [T.TREE_MAGICA]: '#6a2aaa',
  [T.TREE_MANGUE]: '#2a6a20',
  [T.TREE_PINHEIRO]: '#0e4a20',
  [T.TREE_PINOS]: '#1a5a1a',
};

// Tile icons/symbols for the editor
const TILE_ICONS = {
  [T.GRASS]: 'üü©', [T.DARK_GRASS]: 'üåø', [T.TALL_GRASS]: 'üåæ',
  [T.FLOWERS]: 'üå∏', [T.MUSHROOM]: 'üçÑ', [T.BUSH]: 'üå≥',
  [T.ROCK]: 'ü™®', [T.DIRT]: 'üü´', [T.STONE_PATH]: '‚¨ú',
  [T.STONE_WALL]: 'üß±', [T.WATER]: 'üü¶', [T.WATER_RIVER]: 'üíß', [T.TREE_CARVALHO]: 'üå≥',
  [T.WOOD_FLOOR]: 'üüß', [T.CHURCH_FLOOR]: '‚¨ú', [T.RED_CARPET]: 'üü•',
  [T.ALTAR]: '‚õ™', [T.CROSS]: '‚úùÔ∏è', [T.CHURCH_PEW]: 'ü™ë',
  [T.BOOKSHELF]: 'üìö', [T.WOOD_WALL]: 'üü´', [T.WINDOW_STONE]: 'ü™ü',
  [T.WINDOW_WOOD]: 'ü™ü', [T.TABLE]: 'ü™µ', [T.CHAIR]: 'ü™ë',
  [T.WELL]: '‚õ≤', [T.FENCE]: 'üèóÔ∏è', [T.ROOF_STONE]: 'üè†',
  [T.ROOF_WOOD]: 'üè°', [T.SAND]: 'üü®', [T.ANVIL]: 'üî®',
  [T.FURNACE]: 'üî•', [T.BARREL]: 'üõ¢Ô∏è', [T.CRATE]: 'üì¶',
  [T.TORCH_WALL]: 'üî•', [T.BED]: 'üõèÔ∏è', [T.RUG]: 'üü´',
  [T.MUD]: 'üí©', [T.HAY]: 'üåæ', [T.GRAVESTONE]: 'ü™¶',
  [T.DEAD_TREE]: 'üåµ', [T.BONE]: 'ü¶¥', [T.CHURCH_WALL]: 'üèõÔ∏è',
  [T.ROOF_RED]: 'üî¥', [T.ROOF_BLUE]: 'üîµ', [T.ROOF_YELLOW]: 'üü°', [T.BENCH]: 'ü™ë',
  [T.TREE_BETULA]: 'ÔøΩ', [T.TREE_CARVALHO_SMALL]: 'üå±', [T.TREE_MAGICA]: '‚ú®',
  [T.TREE_MANGUE]: 'üå¥', [T.TREE_PINHEIRO]: 'üå≤', [T.TREE_PINOS]: 'üéÑ'
};

const TILE_NAMES = {};
for (const [name, id] of Object.entries(T)) {
  TILE_NAMES[id] = name;
}

// ============================
// STATE
// ============================
let mapData = null;
let mapW = 100, mapH = 100;
let currentQuadrant = 'E5';
let selectedTile = T.GRASS;
let currentTool = 'paint';
let brushSize = 1;
let showGrid = true;
let zoom = 1;
let offsetX = 0, offsetY = 0;
let isPanning = false;
let panStartX = 0, panStartY = 0;
let isPainting = false;
let undoStack = [];
const MAX_UNDO = 50;
let rectStart = null; // for rect tool
let lineStart = null; // for line tool
let blockedTiles = new Set();
let showBlockedOverlay = true;
let showCollisionOverlay = true;
let showNpcOverlay = true;

// Per-cell solid grid
let solidCellSet = new Set(); // "x,y" strings
let isCollisionPainting = false;
let collisionPaintMode = null; // 'add' or 'remove'

// Per-cell "behind" grid (tiles where player passes behind objects)
let behindCellSet = new Set(); // "x,y" strings
let isBehindPainting = false;
let behindPaintMode = null; // 'add' or 'remove'
let showBehindOverlay = true;

// NPC data
let editorNpcs = []; // {id, name, x, y, sprite}
let npcSprites = {}; // id -> Image
let draggingNpc = null;
let npcDragOffsetX = 0;
let npcDragOffsetY = 0;
let isDraggingNpc = false;

// Mob spawn data
let editorSpawns = []; // {id, type, x, y, count, radius}
let selectedSpawn = null;
let isDraggingSpawn = false;
let spawnDragOffsetX = 0;
let spawnDragOffsetY = 0;
let showSpawnOverlay = true;

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; // base tile size for editor

// ============================
// PALETTE GENERATION
// ============================
function buildPalette() {
  const palette = document.getElementById('palette');
  palette.innerHTML = '';
  const sorted = Object.entries(T).sort((a, b) => a[1] - b[1]);
  for (const [name, id] of sorted) {
    const btn = document.createElement('button');
    btn.className = 'tile-btn' + (id === selectedTile ? ' selected' : '');
    btn.dataset.tileId = id;
    btn.dataset.tileName = name.toLowerCase();

    const preview = document.createElement('canvas');
    preview.className = 'tile-preview';
    preview.width = 24;
    preview.height = 24;
    const pc = preview.getContext('2d');
    pc.fillStyle = TILE_COLORS[id] || '#333';
    pc.fillRect(0, 0, 24, 24);
    // Add a subtle inner border
    pc.strokeStyle = 'rgba(255,255,255,0.15)';
    pc.strokeRect(0.5, 0.5, 23, 23);

    const label = document.createElement('span');
    label.textContent = `${TILE_ICONS[id] || '‚ùì'} ${name} (${id})`;

    // Solid indicator
    const solidBadge = document.createElement('span');
    solidBadge.className = 'solid-badge';
    solidBadge.dataset.tileId = id;
    solidBadge.style.cssText = 'margin-left:auto; font-size:10px; padding:1px 4px; border-radius:3px; flex-shrink:0;';
    updateSolidBadge(solidBadge, id);

    btn.appendChild(preview);
    btn.appendChild(label);
    btn.appendChild(solidBadge);
    btn.onclick = () => selectTile(id);
    palette.appendChild(btn);
  }
}

function updateSolidBadge(badge, id) {
  if (blockedTiles.has(id)) {
    badge.textContent = 'üß±';
    badge.style.background = 'rgba(170,40,0,0.4)';
  } else {
    badge.textContent = 'üö∂';
    badge.style.background = 'rgba(0,120,60,0.3)';
  }
}

function refreshAllSolidBadges() {
  document.querySelectorAll('.solid-badge').forEach(b => {
    updateSolidBadge(b, +b.dataset.tileId);
  });
}

async function toggleSelectedTileSolid() {
  const id = selectedTile;
  if (blockedTiles.has(id)) {
    blockedTiles.delete(id);
  } else {
    blockedTiles.add(id);
  }
  refreshAllSolidBadges();
  renderMap();
  // Save to server
  try {
    await fetch('/api/editor/blocked', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ blocked: [...blockedTiles] })
    });
    showToast(blockedTiles.has(id) ? 'üß± Tile agora √© s√≥lido' : 'üö∂ Tile agora √© pass√°vel');
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

function selectTile(id) {
  selectedTile = id;
  document.querySelectorAll('.tile-btn').forEach(b => {
    b.classList.toggle('selected', +b.dataset.tileId === id);
  });
  const solidText = blockedTiles.has(id) ? ' [S√ìLIDO]' : '';
  document.getElementById('selectedInfo').textContent = `${TILE_NAMES[id]} (${id})${solidText}`;
}

function filterTiles(query) {
  const q = query.toLowerCase();
  document.querySelectorAll('.tile-btn').forEach(btn => {
    btn.style.display = btn.dataset.tileName.includes(q) ? '' : 'none';
  });
}

function setTool(tool) {
  currentTool = tool;
  document.querySelectorAll('#tools button').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('tool-' + tool);
  if (btn) btn.classList.add('active');
  rectStart = null;
  lineStart = null;
  // Show/hide panels
  document.getElementById('image-panel').style.display = (tool === 'image') ? 'block' : 'none';
  document.getElementById('collision-panel').style.display = (tool === 'collision') ? 'block' : 'none';
  document.getElementById('behind-panel').style.display = (tool === 'behind') ? 'block' : 'none';
  document.getElementById('npc-panel').style.display = (tool === 'npc') ? 'block' : 'none';
  document.getElementById('spawn-panel').style.display = (tool === 'spawn') ? 'block' : 'none';
  if (tool !== 'selectobj') {
    deselectObj();
  }
  if (tool === 'npc') {
    refreshNpcList();
  }
  if (tool === 'spawn') {
    refreshSpawnList();
  }
  if (tool === 'collision') {
    updateSolidCount();
  }
  if (tool === 'behind') {
    updateBehindCount();
  }
}

function toggleGrid() {
  showGrid = !showGrid;
  document.getElementById('grid-toggle').textContent = 'Grid: ' + (showGrid ? 'ON' : 'OFF');
  renderMap();
}

// ============================
// MAP LOADING / SAVING
// ============================
async function loadQuadrant(q) {
  currentQuadrant = q;
  try {
    const res = await fetch(`/api/editor/map/${q}`);
    const data = await res.json();
    mapData = data.map;
    mapW = data.width;
    mapH = data.height;
    mapObjects = data.objects || [];
    mapObjectImages = {};
    loadAllObjectImages();
    if (data.blockedTiles) {
      blockedTiles = new Set(data.blockedTiles);
      refreshAllSolidBadges();
    }
    // Load NPCs
    editorNpcs = data.npcs || [];
    loadNpcSprites();
    refreshNpcList();
    // Load per-cell solid grid
    solidCellSet = new Set(data.solidCells || []);
    updateSolidCount();
    // Load per-cell behind grid
    behindCellSet = new Set(data.behindCells || []);
    updateBehindCount();
    // Load mob spawns
    editorSpawns = data.spawns || [];
    selectedSpawn = null;
    refreshSpawnList();
    document.getElementById('mapSize').textContent = `${mapW}x${mapH}`;
    undoStack = [];
    offsetX = 0;
    offsetY = 0;
    resizeCanvas();
    renderMap();
    showToast(`Mapa ${q} carregado!`);
  } catch (e) {
    showToast('Erro ao carregar mapa: ' + e.message);
  }
}

async function saveMap() {
  if (!mapData) return;
  try {
    const res = await fetch(`/api/editor/map/${currentQuadrant}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ map: mapData })
    });
    const data = await res.json();
    if (data.success) {
      showToast('‚úÖ Mapa salvo com sucesso!');
    } else {
      showToast('‚ùå Erro: ' + (data.error || 'Desconhecido'));
    }
  } catch (e) {
    showToast('‚ùå Erro ao salvar: ' + e.message);
  }
}

function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.style.display = 'block';
  setTimeout(() => { toast.style.display = 'none'; }, 2000);
}

// ============================
// UNDO SYSTEM
// ============================
function pushUndo(changes) {
  if (changes.length === 0) return;
  undoStack.push(changes);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undo() {
  if (undoStack.length === 0) return;
  const changes = undoStack.pop();
  for (const c of changes) {
    mapData[c.y][c.x] = c.oldTile;
  }
  renderMap();
  showToast('‚Ü© Desfeito');
}

// ============================
// PAINTING
// ============================
let currentUndoBatch = [];

function setTileAt(x, y, tileId) {
  if (x < 0 || y < 0 || x >= mapW || y >= mapH) return;
  if (mapData[y][x] === tileId) return;
  currentUndoBatch.push({ x, y, oldTile: mapData[y][x] });
  mapData[y][x] = tileId;
}

function paintAt(mx, my) {
  const { tx, ty } = screenToTile(mx, my);
  const half = Math.floor(brushSize / 2);
  const tile = currentTool === 'erase' ? T.GRASS : selectedTile;
  for (let dy = -half; dy < brushSize - half; dy++) {
    for (let dx = -half; dx < brushSize - half; dx++) {
      setTileAt(tx + dx, ty + dy, tile);
    }
  }
}

function floodFill(startX, startY, newTile) {
  if (startX < 0 || startY < 0 || startX >= mapW || startY >= mapH) return;
  const oldTile = mapData[startY][startX];
  if (oldTile === newTile) return;

  const stack = [[startX, startY]];
  const visited = new Set();
  let count = 0;
  const MAX_FILL = 10000;

  while (stack.length > 0 && count < MAX_FILL) {
    const [x, y] = stack.pop();
    const key = y * mapW + x;
    if (visited.has(key)) continue;
    if (x < 0 || y < 0 || x >= mapW || y >= mapH) continue;
    if (mapData[y][x] !== oldTile) continue;

    visited.add(key);
    setTileAt(x, y, newTile);
    count++;

    stack.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
  }
}

function drawRect(x1, y1, x2, y2, tileId) {
  const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
  const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
  for (let y = minY; y <= maxY; y++)
    for (let x = minX; x <= maxX; x++)
      setTileAt(x, y, tileId);
}

function drawLine(x1, y1, x2, y2, tileId) {
  const dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
  const sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
  let err = dx - dy;
  let x = x1, y = y1;
  while (true) {
    const half = Math.floor(brushSize / 2);
    for (let bdy = -half; bdy < brushSize - half; bdy++)
      for (let bdx = -half; bdx < brushSize - half; bdx++)
        setTileAt(x + bdx, y + bdy, tileId);
    if (x === x2 && y === y2) break;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x += sx; }
    if (e2 < dx) { err += dx; y += sy; }
  }
}

// ============================
// COORDINATE HELPERS
// ============================
function screenToTile(mx, my) {
  const rect = canvas.getBoundingClientRect();
  const px = (mx - rect.left) / zoom + offsetX;
  const py = (my - rect.top) / zoom + offsetY;
  return { tx: Math.floor(px / TILE_SIZE), ty: Math.floor(py / TILE_SIZE) };
}

// ============================
// RENDERING
// ============================
function resizeCanvas() {
  const area = document.getElementById('canvas-area');
  canvas.width = area.clientWidth;
  canvas.height = area.clientHeight;
}

function renderMap() {
  if (!mapData) return;
  ctx.imageSmoothingEnabled = false;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(-offsetX, -offsetY);

  // Visible range
  const startTX = Math.max(0, Math.floor(offsetX / TILE_SIZE));
  const startTY = Math.max(0, Math.floor(offsetY / TILE_SIZE));
  const endTX = Math.min(mapW, Math.ceil((offsetX + canvas.width / zoom) / TILE_SIZE) + 1);
  const endTY = Math.min(mapH, Math.ceil((offsetY + canvas.height / zoom) / TILE_SIZE) + 1);

  for (let ty = startTY; ty < endTY; ty++) {
    for (let tx = startTX; tx < endTX; tx++) {
      const tile = mapData[ty][tx];
      const sx = tx * TILE_SIZE;
      const sy = ty * TILE_SIZE;

      // Fill tile color
      ctx.fillStyle = TILE_COLORS[tile] || '#ff00ff';
      ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);

      // Add subtle detail marks for certain tiles
      if (tile === T.TREE_CARVALHO) {
        // Grande: copa larga e escura
        ctx.fillStyle = '#0a3005';
        ctx.fillRect(sx + 2, sy + 2, 12, 10);
        ctx.fillStyle = '#1d5a0e';
        ctx.fillRect(sx + 3, sy + 3, 10, 8);
        ctx.fillStyle = '#5a3818';
        ctx.fillRect(sx + 7, sy + 10, 2, 5); // tronco
      } else if (tile === T.TREE_CARVALHO_SMALL) {
        // Pequeno: copa menor e mais clara
        ctx.fillStyle = '#2a6a18';
        ctx.fillRect(sx + 4, sy + 4, 8, 6);
        ctx.fillStyle = '#5aaa30';
        ctx.fillRect(sx + 5, sy + 5, 6, 4);
        ctx.fillStyle = '#6a4828';
        ctx.fillRect(sx + 7, sy + 9, 2, 4); // tronco
      } else if (tile === T.TREE_BETULA || tile === T.TREE_MAGICA ||
          tile === T.TREE_MANGUE || tile === T.TREE_PINHEIRO || tile === T.TREE_PINOS) {
        ctx.fillStyle = '#143d08';
        ctx.fillRect(sx + 3, sy + 3, 10, 10);
        ctx.fillStyle = '#1d5a0e';
        ctx.fillRect(sx + 4, sy + 4, 8, 8);
      } else if (tile === T.WATER) {
        ctx.fillStyle = '#3070d0';
        ctx.fillRect(sx + 2, sy + 6, 12, 2);
        ctx.fillRect(sx + 5, sy + 10, 8, 2);
      } else if (tile === T.WATER_RIVER) {
        ctx.fillStyle = '#5ab0e8';
        ctx.fillRect(sx + 1, sy + 5, 14, 2);
        ctx.fillRect(sx + 3, sy + 9, 10, 2);
        ctx.fillStyle = '#7ac8f0';
        ctx.fillRect(sx + 4, sy + 6, 4, 1);
      } else if (tile === T.WELL) {
        ctx.fillStyle = '#333';
        ctx.fillRect(sx + 2, sy + 2, 12, 12);
        ctx.fillStyle = '#2060c0';
        ctx.fillRect(sx + 4, sy + 4, 8, 8);
      } else if (tile === T.FLOWERS) {
        ctx.fillStyle = '#ff6688';
        ctx.fillRect(sx + 3, sy + 4, 2, 2);
        ctx.fillRect(sx + 9, sy + 7, 2, 2);
        ctx.fillRect(sx + 6, sy + 10, 2, 2);
      } else if (tile === T.GRAVESTONE) {
        ctx.fillStyle = '#aaa';
        ctx.fillRect(sx + 4, sy + 3, 8, 10);
        ctx.fillStyle = '#999';
        ctx.fillRect(sx + 4, sy + 3, 8, 2);
      } else if (tile === T.CROSS) {
        ctx.fillStyle = '#c09030';
        ctx.fillRect(sx + 7, sy + 2, 2, 12);
        ctx.fillRect(sx + 4, sy + 5, 8, 2);
      } else if (tile === T.TORCH_WALL) {
        ctx.fillStyle = '#ffcc00';
        ctx.fillRect(sx + 6, sy + 2, 4, 4);
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(sx + 7, sy + 1, 2, 3);
      } else if (tile === T.WINDOW_STONE || tile === T.WINDOW_WOOD) {
        ctx.fillStyle = '#aaddff';
        ctx.fillRect(sx + 3, sy + 3, 10, 10);
        ctx.fillStyle = tile === T.WINDOW_STONE ? '#555' : '#5a3818';
        ctx.fillRect(sx + 7, sy + 3, 2, 10);
        ctx.fillRect(sx + 3, sy + 7, 10, 2);
      }

      // Blocked tile overlay
      if (showBlockedOverlay && blockedTiles.has(tile)) {
        ctx.fillStyle = 'rgba(255,0,0,0.18)';
        ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
        // Small X mark
        ctx.strokeStyle = 'rgba(255,60,60,0.5)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(sx + 2, sy + 2); ctx.lineTo(sx + TILE_SIZE - 2, sy + TILE_SIZE - 2);
        ctx.moveTo(sx + TILE_SIZE - 2, sy + 2); ctx.lineTo(sx + 2, sy + TILE_SIZE - 2);
        ctx.stroke();
      }

      // Grid
      if (showGrid && zoom >= 0.5) {
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.strokeRect(sx + 0.5, sy + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
      }
    }
  }

  // Draw image objects
  drawObjects();

  // Draw per-cell solid overlay
  if (showCollisionOverlay && solidCellSet.size > 0) {
    for (const key of solidCellSet) {
      const [cx, cy] = key.split(',').map(Number);
      if (cx < startTX || cx >= endTX || cy < startTY || cy >= endTY) continue;
      const sx = cx * TILE_SIZE;
      const sy = cy * TILE_SIZE;
      ctx.fillStyle = 'rgba(255,100,0,0.3)';
      ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
      // Diagonal lines pattern
      ctx.strokeStyle = 'rgba(255,100,0,0.6)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy); ctx.lineTo(sx + TILE_SIZE, sy + TILE_SIZE);
      ctx.moveTo(sx + TILE_SIZE, sy); ctx.lineTo(sx, sy + TILE_SIZE);
      ctx.stroke();
    }
  }

  // Draw per-cell behind overlay
  if (showBehindOverlay && behindCellSet.size > 0) {
    for (const key of behindCellSet) {
      const [cx, cy] = key.split(',').map(Number);
      if (cx < startTX || cx >= endTX || cy < startTY || cy >= endTY) continue;
      const sx = cx * TILE_SIZE;
      const sy = cy * TILE_SIZE;
      ctx.fillStyle = 'rgba(0,100,255,0.25)';
      ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
      // Draw a "B" marker
      ctx.fillStyle = 'rgba(100,180,255,0.7)';
      ctx.font = `${Math.max(6, TILE_SIZE * 0.6)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('B', sx + TILE_SIZE / 2, sy + TILE_SIZE / 2);
    }
  }

  // Draw NPCs
  if (showNpcOverlay) {
    drawEditorNpcs();
  }

  // Draw mob spawns
  if (showSpawnOverlay) {
    drawEditorSpawns();
  }

  // Draw brush preview
  if (lastMouseTile) {
    const half = Math.floor(brushSize / 2);
    ctx.strokeStyle = '#e94560';
    ctx.lineWidth = 1 / zoom;
    for (let dy = -half; dy < brushSize - half; dy++) {
      for (let dx = -half; dx < brushSize - half; dx++) {
        const bx = (lastMouseTile.tx + dx) * TILE_SIZE;
        const by = (lastMouseTile.ty + dy) * TILE_SIZE;
        ctx.strokeRect(bx + 0.5, by + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
      }
    }
  }

  ctx.restore();
}

let lastMouseTile = null;

// ============================
// EVENT HANDLING
// ============================
canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('mousedown', (e) => {
  if (!mapData) return;

  const { tx, ty } = screenToTile(e.clientX, e.clientY);

  // Collision tool: right-click = add solid, left-click = remove solid
  if (currentTool === 'collision') {
    if (e.button === 2) {
      // Right click = add solid
      isCollisionPainting = true;
      collisionPaintMode = 'add';
      paintCollision(tx, ty, 'add');
      renderMap();
      return;
    }
    if (e.button === 0 && !e.altKey) {
      // Left click = remove solid
      isCollisionPainting = true;
      collisionPaintMode = 'remove';
      paintCollision(tx, ty, 'remove');
      renderMap();
      return;
    }
    if (e.button === 0 && e.altKey) {
      // Alt+Click = pan
      isPanning = true;
      panStartX = e.clientX;
      panStartY = e.clientY;
      return;
    }
  }

  // Behind tool: right-click = add behind, left-click = remove behind
  if (currentTool === 'behind') {
    if (e.button === 2) {
      isBehindPainting = true;
      behindPaintMode = 'add';
      paintBehind(tx, ty, 'add');
      renderMap();
      return;
    }
    if (e.button === 0 && !e.altKey) {
      isBehindPainting = true;
      behindPaintMode = 'remove';
      paintBehind(tx, ty, 'remove');
      renderMap();
      return;
    }
    if (e.button === 0 && e.altKey) {
      isPanning = true;
      panStartX = e.clientX;
      panStartY = e.clientY;
      return;
    }
  }

  // NPC tool: drag NPCs
  if (currentTool === 'npc' && e.button === 0 && !e.altKey) {
    const clickedNpc = editorNpcs.find(n => {
      const nx = Math.floor(n.x);
      const ny = Math.floor(n.y);
      return tx >= nx - 1 && tx <= nx + 1 && ty >= ny - 1 && ty <= ny + 1;
    });
    if (clickedNpc) {
      draggingNpc = clickedNpc;
      isDraggingNpc = true;
      npcDragOffsetX = tx - Math.floor(clickedNpc.x);
      npcDragOffsetY = ty - Math.floor(clickedNpc.y);
      return;
    }
  }

  // Spawn tool: click to select/drag existing spawn, or place new one
  if (currentTool === 'spawn' && e.button === 0 && !e.altKey) {
    // Check if clicking on an existing spawn
    const clickedSpawn = editorSpawns.find(s => {
      const dx = tx - s.x, dy = ty - s.y;
      return Math.sqrt(dx*dx + dy*dy) <= 2;
    });
    if (clickedSpawn) {
      selectSpawn(clickedSpawn);
      isDraggingSpawn = true;
      spawnDragOffsetX = tx - clickedSpawn.x;
      spawnDragOffsetY = ty - clickedSpawn.y;
      renderMap();
      return;
    } else {
      // Place new spawn
      placeSpawn(tx, ty);
      return;
    }
  }

  if (e.button === 2 || (e.button === 0 && e.altKey)) {
    // Right click or Alt+Click = pan
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    return;
  }

  if (e.button === 0) {
    const { tx, ty } = screenToTile(e.clientX, e.clientY);

    if (currentTool === 'image') {
      placeImageObject(tx, ty);
      return;
    }

    if (currentTool === 'selectobj') {
      // Check if clicking on a resize handle of selected obj
      if (selectedObj) {
        const handle = getResizeHandle(tx, ty, selectedObj);
        if (handle) {
          isResizingObj = true;
          resizeHandle = handle;
          resizeOriginal = { x: selectedObj.x, y: selectedObj.y, width: selectedObj.width, height: selectedObj.height };
          return;
        }
      }
      // Check if clicking on an object
      // Search in reverse so top-most (last drawn) objects are picked first
      let clicked = null;
      for (let i = mapObjects.length - 1; i >= 0; i--) {
        const o = mapObjects[i];
        if (tx >= o.x && tx < o.x + o.width && ty >= o.y && ty < o.y + o.height) {
          clicked = o;
          break;
        }
      }
      if (clicked) {
        selectObj(clicked);
        isDraggingObj = true;
        dragObjOffsetX = tx - clicked.x;
        dragObjOffsetY = ty - clicked.y;
      } else {
        deselectObj();
      }
      return;
    }

    if (currentTool === 'pick') {
      // Eyedropper
      if (tx >= 0 && ty >= 0 && tx < mapW && ty < mapH) {
        selectTile(mapData[ty][tx]);
        setTool('paint');
      }
      return;
    }

    if (currentTool === 'fill') {
      currentUndoBatch = [];
      floodFill(tx, ty, selectedTile);
      pushUndo(currentUndoBatch);
      renderMap();
      return;
    }

    if (currentTool === 'rect') {
      if (!rectStart) {
        rectStart = { tx, ty };
      } else {
        currentUndoBatch = [];
        drawRect(rectStart.tx, rectStart.ty, tx, ty, selectedTile);
        pushUndo(currentUndoBatch);
        rectStart = null;
        renderMap();
      }
      return;
    }

    if (currentTool === 'line') {
      if (!lineStart) {
        lineStart = { tx, ty };
      } else {
        currentUndoBatch = [];
        drawLine(lineStart.tx, lineStart.ty, tx, ty, selectedTile);
        pushUndo(currentUndoBatch);
        lineStart = null;
        renderMap();
      }
      return;
    }

    // Paint / Erase
    isPainting = true;
    currentUndoBatch = [];
    paintAt(e.clientX, e.clientY);
    renderMap();
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (!mapData) return;

  const { tx, ty } = screenToTile(e.clientX, e.clientY);
  lastMouseTile = { tx, ty };
  document.getElementById('coords').textContent = `X: ${tx}, Y: ${ty} | Tile: ${TILE_NAMES[mapData?.[ty]?.[tx]] || '?'}${solidCellSet.has(`${tx},${ty}`) ? ' [S√ìLIDO]' : ''}`;

  // Update cursor for resize handles
  if (currentTool === 'selectobj' && selectedObj && !isDraggingObj && !isResizingObj) {
    const handle = getResizeHandle(tx, ty, selectedObj);
    if (handle === 'tl' || handle === 'br') canvas.style.cursor = 'nwse-resize';
    else if (handle === 'tr' || handle === 'bl') canvas.style.cursor = 'nesw-resize';
    else if (handle === 't' || handle === 'b') canvas.style.cursor = 'ns-resize';
    else if (handle === 'l' || handle === 'r') canvas.style.cursor = 'ew-resize';
    else canvas.style.cursor = 'default';
  } else if (isResizingObj) {
    // Keep cursor during resize
  } else {
    canvas.style.cursor = 'default';
  }

  if (isPanning) {
    const dx = e.clientX - panStartX;
    const dy = e.clientY - panStartY;
    offsetX -= dx / zoom;
    offsetY -= dy / zoom;
    panStartX = e.clientX;
    panStartY = e.clientY;
    renderMap();
    return;
  }

  // Collision painting drag
  if (isCollisionPainting && collisionPaintMode) {
    paintCollision(tx, ty, collisionPaintMode);
    renderMap();
    return;
  }

  // Behind painting drag
  if (isBehindPainting && behindPaintMode) {
    paintBehind(tx, ty, behindPaintMode);
    renderMap();
    return;
  }

  // NPC dragging
  if (isDraggingNpc && draggingNpc) {
    const newX = tx - npcDragOffsetX;
    const newY = ty - npcDragOffsetY;
    if (newX !== Math.floor(draggingNpc.x) || newY !== Math.floor(draggingNpc.y)) {
      draggingNpc.x = Math.max(0, Math.min(mapW - 1, newX));
      draggingNpc.y = Math.max(0, Math.min(mapH - 1, newY));
      renderMap();
    }
    return;
  }

  // Spawn dragging
  if (isDraggingSpawn && selectedSpawn) {
    const newX = tx - spawnDragOffsetX;
    const newY = ty - spawnDragOffsetY;
    if (newX !== selectedSpawn.x || newY !== selectedSpawn.y) {
      selectedSpawn.x = Math.max(0, Math.min(mapW - 1, newX));
      selectedSpawn.y = Math.max(0, Math.min(mapH - 1, newY));
      renderMap();
    }
    return;
  }

  // Resize dragging (mant√©m aspect ratio da imagem original)
  if (isResizingObj && selectedObj && resizeHandle && resizeOriginal) {
    const img = mapObjectImages[selectedObj.id];
    const hasImg = img && img.complete && img.naturalWidth;
    const origAspect = hasImg ? img.naturalHeight / img.naturalWidth : (resizeOriginal.height / resizeOriginal.width);
    
    let nx = resizeOriginal.x, ny = resizeOriginal.y;
    let nw = resizeOriginal.width, nh = resizeOriginal.height;

    // Determine the primary axis being dragged
    const isHorizontal = resizeHandle === 'l' || resizeHandle === 'r';
    const isVertical = resizeHandle === 't' || resizeHandle === 'b';
    const isCorner = !isHorizontal && !isVertical;

    if (isHorizontal || isCorner) {
      if (resizeHandle.includes('r')) {
        nw = Math.max(1, tx - resizeOriginal.x + 1);
      }
      if (resizeHandle.includes('l')) {
        const right = resizeOriginal.x + resizeOriginal.width;
        nx = Math.min(tx, right - 1);
        nw = right - nx;
      }
      // Adjust height to maintain aspect ratio
      nh = Math.max(1, Math.round(nw * origAspect));
      if (resizeHandle.includes('t')) {
        ny = resizeOriginal.y + resizeOriginal.height - nh;
      }
    } else {
      // Pure vertical drag
      if (resizeHandle.includes('b')) {
        nh = Math.max(1, ty - resizeOriginal.y + 1);
      }
      if (resizeHandle.includes('t')) {
        const bottom = resizeOriginal.y + resizeOriginal.height;
        ny = Math.min(ty, bottom - 1);
        nh = bottom - ny;
      }
      // Adjust width to maintain aspect ratio
      nw = Math.max(1, Math.round(nh / origAspect));
      if (resizeHandle.includes('l')) {
        nx = resizeOriginal.x + resizeOriginal.width - nw;
      }
    }

    selectedObj.x = Math.max(0, nx);
    selectedObj.y = Math.max(0, ny);
    selectedObj.width = Math.max(1, nw);
    selectedObj.height = Math.max(1, nh);
    document.getElementById('objX').value = selectedObj.x;
    document.getElementById('objY').value = selectedObj.y;
    document.getElementById('objW').value = selectedObj.width;
    document.getElementById('objH').value = selectedObj.height;
    renderMap();
    return;
  }

  if (isDraggingObj && selectedObj) {
    const newX = tx - dragObjOffsetX;
    const newY = ty - dragObjOffsetY;
    if (newX !== selectedObj.x || newY !== selectedObj.y) {
      selectedObj.x = Math.max(0, Math.min(mapW - selectedObj.width, newX));
      selectedObj.y = Math.max(0, Math.min(mapH - selectedObj.height, newY));
      document.getElementById('objX').value = selectedObj.x;
      document.getElementById('objY').value = selectedObj.y;
      renderMap();
    }
    return;
  }

  if (isPainting) {
    paintAt(e.clientX, e.clientY);
    renderMap();
  } else {
    renderMap(); // update brush preview
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (isPanning) {
    isPanning = false;
    return;
  }
  if (isCollisionPainting) {
    isCollisionPainting = false;
    collisionPaintMode = null;
    saveSolidCells();
    return;
  }
  if (isBehindPainting) {
    isBehindPainting = false;
    behindPaintMode = null;
    saveBehindCells();
    return;
  }
  if (isDraggingNpc && draggingNpc) {
    isDraggingNpc = false;
    saveNpcPosition(draggingNpc);
    draggingNpc = null;
    return;
  }
  if (isDraggingSpawn && selectedSpawn) {
    isDraggingSpawn = false;
    saveSpawnToServer(selectedSpawn);
    refreshSpawnList();
    return;
  }
  if (isResizingObj && selectedObj) {
    isResizingObj = false;
    resizeHandle = null;
    resizeOriginal = null;
    saveSelectedObjToServer();
    showToast(`üìê Objeto redimensionado: ${selectedObj.width}x${selectedObj.height}`);
    return;
  }
  if (isDraggingObj && selectedObj) {
    isDraggingObj = false;
    saveSelectedObjToServer();
    return;
  }
  if (isPainting) {
    isPainting = false;
    pushUndo(currentUndoBatch);
    currentUndoBatch = [];
  }
});

canvas.addEventListener('mouseleave', () => {
  isPanning = false;
  if (isCollisionPainting) {
    isCollisionPainting = false;
    collisionPaintMode = null;
    saveSolidCells();
  }
  if (isBehindPainting) {
    isBehindPainting = false;
    behindPaintMode = null;
    saveBehindCells();
  }
  if (isDraggingNpc && draggingNpc) {
    isDraggingNpc = false;
    saveNpcPosition(draggingNpc);
    draggingNpc = null;
  }
  if (isDraggingSpawn && selectedSpawn) {
    isDraggingSpawn = false;
    saveSpawnToServer(selectedSpawn);
  }
  if (isResizingObj && selectedObj) {
    isResizingObj = false;
    resizeHandle = null;
    resizeOriginal = null;
    saveSelectedObjToServer();
  }
  if (isDraggingObj && selectedObj) {
    isDraggingObj = false;
    saveSelectedObjToServer();
  }
  if (isPainting) {
    isPainting = false;
    pushUndo(currentUndoBatch);
    currentUndoBatch = [];
  }
  lastMouseTile = null;
  renderMap();
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const { tx, ty } = screenToTile(e.clientX, e.clientY);
  const oldZoom = zoom;

  if (e.deltaY < 0) zoom = Math.min(zoom * 1.15, 8);
  else zoom = Math.max(zoom / 1.15, 0.2);

  // Zoom toward mouse position
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  offsetX = (offsetX + mx / oldZoom) - mx / zoom;
  offsetY = (offsetY + my / oldZoom) - my / zoom;

  renderMap();
}, { passive: false });

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;

  if (e.ctrlKey && e.key === 'z') { undo(); e.preventDefault(); }
  if (e.key === 'g' || e.key === 'G') toggleGrid();
  if (e.key === 'e' || e.key === 'E') setTool('pick');
  if (e.key === 'f' || e.key === 'F') setTool('fill');
  if (e.key === 'b' || e.key === 'B') setTool('paint');
  if (e.key === 'r' || e.key === 'R') setTool('rect');
  if (e.key === 'l' || e.key === 'L') setTool('line');
  if (e.key === 'x' || e.key === 'X') setTool('erase');
  if (e.key === 'i' || e.key === 'I') setTool('image');
  if (e.key === 's' || e.key === 'S') setTool('selectobj');
  if (e.key === 'n' || e.key === 'N') setTool('npc');
  if (e.key === 'm' || e.key === 'M') setTool('spawn');
  if (e.key === 'c' || e.key === 'C') setTool('collision');
  if (e.key === 'Delete' && selectedObj) deleteSelectedObj();

  // Number keys for brush size
  if (e.key >= '1' && e.key <= '9') {
    brushSize = +e.key;
    document.getElementById('brushRange').value = brushSize;
    document.getElementById('brushVal').textContent = brushSize;
    renderMap();
  }
});

// Window resize
window.addEventListener('resize', () => {
  resizeCanvas();
  renderMap();
});

// ============================
// IMAGE OBJECTS SYSTEM
// ============================
let mapObjects = []; // {id, src, x, y, width, height}
let mapObjectImages = {}; // id -> Image
let pendingImageData = null; // base64 data URL ready to place
let selectedObj = null;
let isDraggingObj = false;
let dragObjOffsetX = 0;
let dragObjOffsetY = 0;

// Resize state
let isResizingObj = false;
let resizeHandle = null; // 'tl','tr','bl','br' (top-left, top-right, etc)
let resizeOriginal = null; // {x, y, width, height} snapshot before resize

function onImageSelected(input) {
  if (!input.files || !input.files[0]) return;
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = (e) => {
    pendingImageData = e.target.result;
    const preview = document.getElementById('imgPreview');
    preview.innerHTML = `<img src="${pendingImageData}" style="max-width:100%; max-height:80px; border:1px solid #555; border-radius:3px;">`;
    showToast('Clique no mapa para posicionar a imagem');
  };
  reader.readAsDataURL(file);
}

async function placeImageObject(tx, ty) {
  if (!pendingImageData) { showToast('Selecione uma imagem primeiro'); return; }
  const baseW = +document.getElementById('imgW').value || 3;
  // Calcula altura mantendo aspect ratio da imagem
  const tmpImg = new Image();
  tmpImg.src = pendingImageData;
  let w = baseW, h = +document.getElementById('imgH').value || 3;
  if (tmpImg.naturalWidth && tmpImg.naturalHeight) {
    const aspect = tmpImg.naturalHeight / tmpImg.naturalWidth;
    h = Math.max(1, Math.round(baseW * aspect));
  }
  try {
    const res = await fetch(`/api/editor/objects/${currentQuadrant}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ src: pendingImageData, x: tx, y: ty, width: w, height: h })
    });
    const data = await res.json();
    if (data.success) {
      mapObjects.push(data.object);
      loadObjectImage(data.object);
      showToast('‚úÖ Imagem posicionada!');
      renderMap();
    } else {
      showToast('‚ùå Erro: ' + (data.error || '?'));
    }
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

function selectObj(obj) {
  selectedObj = obj;
  document.getElementById('obj-panel').style.display = 'block';
  document.getElementById('objX').value = obj.x;
  document.getElementById('objY').value = obj.y;
  document.getElementById('objW').value = obj.width;
  document.getElementById('objH').value = obj.height;
  const preview = document.getElementById('objPreview');
  const img = mapObjectImages[obj.id];
  if (img) {
    preview.innerHTML = `<img src="${img.src}" style="max-width:100%; max-height:60px; border:1px solid #555; border-radius:3px;">`;
  } else {
    preview.innerHTML = '<span style="color:#888">Sem preview</span>';
  }
  renderMap();
}

function deselectObj() {
  selectedObj = null;
  isDraggingObj = false;
  isResizingObj = false;
  resizeHandle = null;
  resizeOriginal = null;
  document.getElementById('obj-panel').style.display = 'none';
  renderMap();
}

// Detect which resize handle the tile coords hit
function getResizeHandle(tx, ty, obj) {
  const margin = 1; // tolerance in tiles
  const ox = obj.x, oy = obj.y;
  const ox2 = obj.x + obj.width - 1;
  const oy2 = obj.y + obj.height - 1;

  const nearLeft = Math.abs(tx - ox) <= margin;
  const nearRight = Math.abs(tx - ox2) <= margin;
  const nearTop = Math.abs(ty - oy) <= margin;
  const nearBottom = Math.abs(ty - oy2) <= margin;
  const nearMidX = Math.abs(tx - Math.floor((ox + ox2) / 2)) <= margin;
  const nearMidY = Math.abs(ty - Math.floor((oy + oy2) / 2)) <= margin;

  // Must be near/outside the edges
  const onEdge = tx <= ox + margin || tx >= ox2 - margin || ty <= oy + margin || ty >= oy2 - margin;
  if (!onEdge) return null;

  // Corners
  if (nearLeft && nearTop) return 'tl';
  if (nearRight && nearTop) return 'tr';
  if (nearLeft && nearBottom) return 'bl';
  if (nearRight && nearBottom) return 'br';
  // Edges
  if (nearTop && nearMidX) return 't';
  if (nearBottom && nearMidX) return 'b';
  if (nearLeft && nearMidY) return 'l';
  if (nearRight && nearMidY) return 'r';

  return null;
}

function getObjAspect() {
  if (!selectedObj) return 1;
  const img = mapObjectImages[selectedObj.id];
  if (img && img.complete && img.naturalWidth) {
    return img.naturalHeight / img.naturalWidth;
  }
  return selectedObj.height / selectedObj.width;
}

async function updateObjWidth() {
  if (!selectedObj) return;
  const w = Math.max(1, +document.getElementById('objW').value || 1);
  const aspect = getObjAspect();
  const h = Math.max(1, Math.round(w * aspect));
  selectedObj.x = +document.getElementById('objX').value;
  selectedObj.y = +document.getElementById('objY').value;
  selectedObj.width = w;
  selectedObj.height = h;
  document.getElementById('objW').value = w;
  document.getElementById('objH').value = h;
  renderMap();
  await saveSelectedObjToServer();
}

async function updateObjHeight() {
  if (!selectedObj) return;
  const h = Math.max(1, +document.getElementById('objH').value || 1);
  const aspect = getObjAspect();
  const w = Math.max(1, Math.round(h / aspect));
  selectedObj.x = +document.getElementById('objX').value;
  selectedObj.y = +document.getElementById('objY').value;
  selectedObj.width = w;
  selectedObj.height = h;
  document.getElementById('objW').value = w;
  document.getElementById('objH').value = h;
  renderMap();
  await saveSelectedObjToServer();
}

async function updateSelectedObjProps() {
  if (!selectedObj) return;
  selectedObj.x = +document.getElementById('objX').value;
  selectedObj.y = +document.getElementById('objY').value;
  selectedObj.width = +document.getElementById('objW').value || 1;
  selectedObj.height = +document.getElementById('objH').value || 1;
  renderMap();
  await saveSelectedObjToServer();
}

async function saveSelectedObjToServer() {
  if (!selectedObj) return;
  try {
    await fetch(`/api/editor/objects/${currentQuadrant}/${selectedObj.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ x: selectedObj.x, y: selectedObj.y, width: selectedObj.width, height: selectedObj.height })
    });
  } catch (e) {
    showToast('‚ùå Erro ao salvar: ' + e.message);
  }
}

async function deleteSelectedObj() {
  if (!selectedObj) return;
  try {
    const res = await fetch(`/api/editor/objects/${currentQuadrant}/${selectedObj.id}`, { method: 'DELETE' });
    const data = await res.json();
    if (data.success) {
      mapObjects = mapObjects.filter(o => o.id !== selectedObj.id);
      delete mapObjectImages[selectedObj.id];
      deselectObj();
      showToast('üóëÔ∏è Objeto removido!');
    }
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

function loadObjectImage(obj) {
  if (!mapObjectImages[obj.id]) {
    const img = new Image();
    img.onload = () => renderMap();
    img.src = obj.src;
    mapObjectImages[obj.id] = img;
  }
}

function loadAllObjectImages() {
  for (const obj of mapObjects) loadObjectImage(obj);
}

function drawObjects() {
  for (const obj of mapObjects) {
    const img = mapObjectImages[obj.id];
    const sx = obj.x * TILE_SIZE;
    const sy = obj.y * TILE_SIZE;
    const sw = obj.width * TILE_SIZE;
    const sh = obj.height * TILE_SIZE;
    if (img && img.complete && img.naturalWidth) {
      ctx.drawImage(img, sx, sy, sw, sh);
    } else {
      // Placeholder
      ctx.fillStyle = 'rgba(128,0,255,0.3)';
      ctx.fillRect(sx, sy, sw, sh);
      ctx.strokeStyle = '#a040ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(sx + 0.5, sy + 0.5, sw - 1, sh - 1);
    }
    // Border indicator
    const isSelected = selectedObj && obj.id === selectedObj.id;
    ctx.strokeStyle = isSelected ? 'rgba(0,255,255,1)' : 'rgba(255,255,0,0.5)';
    ctx.lineWidth = isSelected ? 2 : 0.5;
    ctx.setLineDash(isSelected ? [4,3] : [2,2]);
    ctx.strokeRect(sx, sy, sw, sh);
    ctx.setLineDash([]);
    if (isSelected) {
      // Draw resize handles at corners and edges ‚Äî bigger for easier clicking
      const hs = Math.max(4, 6 / zoom);
      ctx.fillStyle = '#0ff';
      // Corners
      ctx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
      ctx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
      ctx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
      ctx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
      // Edge midpoints
      ctx.fillStyle = '#0aa';
      ctx.fillRect(sx + sw/2 - hs/2, sy - hs/2, hs, hs); // top
      ctx.fillRect(sx + sw/2 - hs/2, sy + sh - hs/2, hs, hs); // bottom
      ctx.fillRect(sx - hs/2, sy + sh/2 - hs/2, hs, hs); // left
      ctx.fillRect(sx + sw - hs/2, sy + sh/2 - hs/2, hs, hs); // right
      // Label size
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(sx, sy - 12, 60, 11);
      ctx.fillStyle = '#0ff';
      ctx.font = '9px sans-serif';
      ctx.fillText(`${obj.width}x${obj.height} tiles`, sx + 2, sy - 3);
    }
  }
}

// ============================
// COLLISION TOOL (per-cell solid)
// ============================
function paintCollision(tx, ty, mode) {
  const half = Math.floor(brushSize / 2);
  for (let dy = -half; dy < brushSize - half; dy++) {
    for (let dx = -half; dx < brushSize - half; dx++) {
      const cx = tx + dx;
      const cy = ty + dy;
      if (cx < 0 || cy < 0 || cx >= mapW || cy >= mapH) continue;
      const key = `${cx},${cy}`;
      if (mode === 'add') {
        solidCellSet.add(key);
      } else {
        solidCellSet.delete(key);
      }
    }
  }
  updateSolidCount();
}

async function saveSolidCells() {
  try {
    // Full replace: send the entire set, server replaces old data
    const res = await fetch(`/api/editor/solidcells/${currentQuadrant}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ cells: [...solidCellSet] })
    });
    const data = await res.json();
    showToast(`üß± ${data.count || solidCellSet.size} c√©lulas s√≥lidas salvas`);
  } catch (e) {
    showToast('‚ùå Erro ao salvar colis√£o: ' + e.message);
  }
}

function updateSolidCount() {
  const el = document.getElementById('solidCount');
  if (el) el.textContent = solidCellSet.size;
}

// ============================
// BEHIND TOOL (per-cell "pass behind" overlay)
// ============================
function paintBehind(tx, ty, mode) {
  const half = Math.floor(brushSize / 2);
  for (let dy = -half; dy < brushSize - half; dy++) {
    for (let dx = -half; dx < brushSize - half; dx++) {
      const cx = tx + dx;
      const cy = ty + dy;
      if (cx < 0 || cy < 0 || cx >= mapW || cy >= mapH) continue;
      const key = `${cx},${cy}`;
      if (mode === 'add') {
        behindCellSet.add(key);
      } else {
        behindCellSet.delete(key);
      }
    }
  }
  updateBehindCount();
}

async function saveBehindCells() {
  try {
    const res = await fetch(`/api/editor/behindcells/${currentQuadrant}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ cells: [...behindCellSet] })
    });
    const data = await res.json();
    showToast(`üî≤ ${data.count || behindCellSet.size} c√©lulas "atr√°s" salvas`);
  } catch (e) {
    showToast('‚ùå Erro ao salvar behind: ' + e.message);
  }
}

function updateBehindCount() {
  const el = document.getElementById('behindCount');
  if (el) el.textContent = behindCellSet.size;
}

// ============================
// NPC SYSTEM (editor)
// ============================
function loadNpcSprites() {
  npcSprites = {};
  for (const npc of editorNpcs) {
    if (!npc.sprite) continue;
    const img = new Image();
    img.onload = () => renderMap();
    img.onerror = () => console.warn(`Sprite NPC n√£o encontrado: ${npc.sprite}`);
    img.src = `/assets/sprites/npcs/${npc.sprite}.png`;
    npcSprites[npc.id] = img;
  }
}

function drawEditorNpcs() {
  for (const npc of editorNpcs) {
    const nx = Math.floor(npc.x) * TILE_SIZE;
    const ny = Math.floor(npc.y) * TILE_SIZE;
    const npcSize = TILE_SIZE * 2; // draw NPC as 2x2 tiles for visibility

    const img = npcSprites[npc.id];
    if (img && img.complete && img.naturalWidth) {
      // Draw sprite centered on tile position
      const drawX = nx - TILE_SIZE / 2;
      const drawY = ny - TILE_SIZE;
      ctx.drawImage(img, drawX, drawY, npcSize, npcSize);
    } else {
      // Fallback: colored circle
      ctx.fillStyle = 'rgba(0,200,255,0.5)';
      ctx.beginPath();
      ctx.arc(nx + TILE_SIZE / 2, ny + TILE_SIZE / 2, TILE_SIZE * 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Name label
    ctx.save();
    const fontSize = Math.max(6, 10 / zoom * zoom);
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#000';
    ctx.fillText(npc.name, nx + TILE_SIZE / 2 + 1, ny - 3 + 1);
    ctx.fillStyle = '#0ff';
    ctx.fillText(npc.name, nx + TILE_SIZE / 2, ny - 3);
    ctx.restore();

    // Selection border when using NPC tool
    if (currentTool === 'npc') {
      ctx.strokeStyle = draggingNpc && draggingNpc.id === npc.id ? '#ff0' : 'rgba(0,255,255,0.6)';
      ctx.lineWidth = draggingNpc && draggingNpc.id === npc.id ? 2 : 1;
      ctx.setLineDash([3, 2]);
      ctx.strokeRect(nx - TILE_SIZE / 2, ny - TILE_SIZE, npcSize, npcSize);
      ctx.setLineDash([]);
    }
  }
}

function refreshNpcList() {
  const list = document.getElementById('npc-list');
  if (!list) return;
  if (editorNpcs.length === 0) {
    list.innerHTML = '<div style="color:#888; font-style:italic;">Nenhum NPC neste quadrante</div>';
    return;
  }
  list.innerHTML = '';
  for (const npc of editorNpcs) {
    const item = document.createElement('div');
    item.style.cssText = 'padding:3px 4px; margin:2px 0; background:rgba(0,200,255,0.1); border-radius:3px; display:flex; align-items:center; gap:6px; cursor:pointer;';
    item.innerHTML = `
      <span style="color:#0ff; font-weight:bold;">üë§</span>
      <span>${npc.name}</span>
      <span style="color:#888; font-size:10px; margin-left:auto;">(${Math.floor(npc.x)}, ${Math.floor(npc.y)})</span>
    `;
    item.onclick = () => {
      // Center view on NPC
      offsetX = npc.x * TILE_SIZE - canvas.width / zoom / 2;
      offsetY = npc.y * TILE_SIZE - canvas.height / zoom / 2;
      renderMap();
    };
    list.appendChild(item);
  }
}

async function saveNpcPosition(npc) {
  try {
    const res = await fetch(`/api/editor/npcs/${npc.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ x: npc.x, y: npc.y })
    });
    const data = await res.json();
    if (data.success) {
      showToast(`üë§ ${npc.name} movido para (${Math.floor(npc.x)}, ${Math.floor(npc.y)})`);
      refreshNpcList();
    } else {
      showToast('‚ùå Erro ao salvar NPC: ' + (data.error || '?'));
    }
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

// ============================
// MOB SPAWN SYSTEM
// ============================
const SPAWN_COLORS = {
  skeleton: { fill: 'rgba(200, 50, 50, 0.25)', stroke: '#cc3333', icon: 'üíÄ' },
  slime: { fill: 'rgba(50, 200, 50, 0.25)', stroke: '#33cc33', icon: 'üü¢' },
  zombie: { fill: 'rgba(100, 50, 150, 0.25)', stroke: '#9944cc', icon: 'üßü' }
};

function drawEditorSpawns() {
  for (const spawn of editorSpawns) {
    const sx = spawn.x * TILE_SIZE;
    const sy = spawn.y * TILE_SIZE;
    const radiusPx = spawn.radius * TILE_SIZE;
    const isSelected = selectedSpawn && selectedSpawn.id === spawn.id;
    const colors = SPAWN_COLORS[spawn.type] || { fill: 'rgba(200,200,50,0.25)', stroke: '#cccc33', icon: '?' };

    // Draw radius circle
    ctx.beginPath();
    ctx.arc(sx + TILE_SIZE / 2, sy + TILE_SIZE / 2, radiusPx, 0, Math.PI * 2);
    ctx.fillStyle = colors.fill;
    ctx.fill();
    ctx.strokeStyle = isSelected ? '#fff' : colors.stroke;
    ctx.lineWidth = isSelected ? 2 : 1;
    ctx.setLineDash(isSelected ? [5, 3] : [3, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw center marker
    ctx.fillStyle = colors.stroke;
    ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);

    // Draw icon
    ctx.save();
    const fontSize = Math.max(8, TILE_SIZE * 0.8);
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(colors.icon, sx + TILE_SIZE / 2, sy + TILE_SIZE / 2);
    ctx.restore();

    // Draw label
    ctx.save();
    const labelSize = Math.max(6, 9);
    ctx.font = `bold ${labelSize}px sans-serif`;
    ctx.textAlign = 'center';
    const label = `${spawn.type} x${spawn.count}`;
    ctx.fillStyle = '#000';
    ctx.fillText(label, sx + TILE_SIZE / 2 + 1, sy - 3 + 1);
    ctx.fillStyle = isSelected ? '#fff' : colors.stroke;
    ctx.fillText(label, sx + TILE_SIZE / 2, sy - 3);
    ctx.restore();

    // Selection highlight
    if (isSelected && currentTool === 'spawn') {
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 2]);
      ctx.strokeRect(sx - 2, sy - 2, TILE_SIZE + 4, TILE_SIZE + 4);
      ctx.setLineDash([]);
    }
  }
}

function refreshSpawnList() {
  const list = document.getElementById('spawn-list');
  if (!list) return;
  if (editorSpawns.length === 0) {
    list.innerHTML = '<div style="color:#888; font-style:italic;">Nenhum spawn neste quadrante</div>';
    return;
  }
  list.innerHTML = '';
  for (const spawn of editorSpawns) {
    const colors = SPAWN_COLORS[spawn.type] || { icon: '?' };
    const item = document.createElement('div');
    item.style.cssText = 'padding:3px 4px; margin:2px 0; background:rgba(200,50,200,0.1); border-radius:3px; display:flex; align-items:center; gap:6px; cursor:pointer;';
    const selStyle = selectedSpawn && selectedSpawn.id === spawn.id ? 'border:1px solid #fff;' : '';
    item.style.cssText += selStyle;
    item.innerHTML = `
      <span>${colors.icon}</span>
      <span>${spawn.type} x${spawn.count}</span>
      <span style="color:#888; font-size:10px; margin-left:auto;">(${spawn.x}, ${spawn.y}) r=${spawn.radius}</span>
    `;
    item.onclick = () => {
      selectSpawn(spawn);
      // Center view on spawn
      offsetX = spawn.x * TILE_SIZE - canvas.width / zoom / 2;
      offsetY = spawn.y * TILE_SIZE - canvas.height / zoom / 2;
      renderMap();
    };
    list.appendChild(item);
  }
}

function selectSpawn(spawn) {
  selectedSpawn = spawn;
  document.getElementById('spawn-sel-panel').style.display = 'block';
  document.getElementById('selSpawnType').value = spawn.type;
  document.getElementById('selSpawnCount').value = spawn.count;
  document.getElementById('selSpawnRadius').value = spawn.radius;
  refreshSpawnList();
  renderMap();
}

function deselectSpawn() {
  selectedSpawn = null;
  isDraggingSpawn = false;
  document.getElementById('spawn-sel-panel').style.display = 'none';
  refreshSpawnList();
  renderMap();
}

async function placeSpawn(tx, ty) {
  const type = document.getElementById('spawnType').value;
  const count = +document.getElementById('spawnCount').value || 4;
  const radius = +document.getElementById('spawnRadius').value || 5;
  try {
    const res = await fetch(`/api/editor/spawns/${currentQuadrant}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type, x: tx, y: ty, count, radius })
    });
    const data = await res.json();
    if (data.success) {
      editorSpawns.push(data.spawn);
      selectSpawn(data.spawn);
      showToast(`üëæ Spawn de ${type} criado!`);
      renderMap();
    } else {
      showToast('‚ùå Erro: ' + (data.error || '?'));
    }
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

async function updateSelectedSpawn() {
  if (!selectedSpawn) return;
  selectedSpawn.type = document.getElementById('selSpawnType').value;
  selectedSpawn.count = +document.getElementById('selSpawnCount').value || 1;
  selectedSpawn.radius = +document.getElementById('selSpawnRadius').value || 1;
  renderMap();
  await saveSpawnToServer(selectedSpawn);
  refreshSpawnList();
}

async function saveSpawnToServer(spawn) {
  try {
    await fetch(`/api/editor/spawns/${currentQuadrant}/${spawn.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ x: spawn.x, y: spawn.y, count: spawn.count, radius: spawn.radius, type: spawn.type })
    });
  } catch (e) {
    showToast('‚ùå Erro ao salvar: ' + e.message);
  }
}

async function deleteSelectedSpawn() {
  if (!selectedSpawn) return;
  try {
    const res = await fetch(`/api/editor/spawns/${currentQuadrant}/${selectedSpawn.id}`, { method: 'DELETE' });
    const data = await res.json();
    if (data.success) {
      editorSpawns = editorSpawns.filter(s => s.id !== selectedSpawn.id);
      deselectSpawn();
      showToast('üóëÔ∏è Spawn removido!');
    }
  } catch (e) {
    showToast('‚ùå Erro: ' + e.message);
  }
}

// ============================
// INIT
// ============================
buildPalette();
resizeCanvas();
// Center view
offsetX = 0;
offsetY = 0;
zoom = 2;
loadQuadrant('E5');
</script>
</body>
</html>
